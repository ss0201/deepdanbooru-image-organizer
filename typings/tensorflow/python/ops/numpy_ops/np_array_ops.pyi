"""
This type stub file was generated by pyright.
"""

import enum
from tensorflow.python.ops.numpy_ops import np_utils

"""Common array methods."""
newaxis = ...
@np_utils.np_doc('empty')
def empty(shape, dtype=...):
  ...

@np_utils.np_doc('empty_like')
def empty_like(a, dtype=...):
  ...

@np_utils.np_doc('zeros')
def zeros(shape, dtype=...):
  ...

@np_utils.np_doc('zeros_like')
def zeros_like(a, dtype=...):
  ...

@np_utils.np_doc('ones')
def ones(shape, dtype=...):
  ...

@np_utils.np_doc('ones_like')
def ones_like(a, dtype=...):
  ...

@np_utils.np_doc('eye')
def eye(N, M=..., k=..., dtype=...):
  ...

@np_utils.np_doc('identity')
def identity(n, dtype=...):
  ...

@np_utils.np_doc('full')
def full(shape, fill_value, dtype=...): # -> _dispatcher_for_broadcast_to | object:
  ...

@np_utils.np_doc_only('full_like')
def full_like(a, fill_value, dtype=..., order=..., subok=..., shape=...): # -> _dispatcher_for_broadcast_to | object:
  """order, subok and shape arguments mustn't be changed."""
  ...

@np_utils.np_doc_only('array')
def array(val, dtype=..., copy=..., ndmin=...): # -> defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | Tensor | _basetuple:
  """Since Tensors are immutable, a copy is made only if val is placed on a

  different device than the current one. Even if `copy` is False, a new Tensor
  may need to be built to satisfy `dtype` and `ndim`. This is used only if `val`
  is an ndarray or a Tensor.
  """
  ...

@np_utils.np_doc('asarray')
def asarray(a, dtype=...): # -> ndarray | defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple:
  ...

@np_utils.np_doc('asanyarray')
def asanyarray(a, dtype=...): # -> ndarray | defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple:
  ...

@np_utils.np_doc('ascontiguousarray')
def ascontiguousarray(a, dtype=...): # -> defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | Tensor | _basetuple:
  ...

@np_utils.np_doc('arange')
def arange(start, stop=..., step=..., dtype=...): # -> defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | Tensor | _basetuple:
  """Returns `step`-separated values in the range [start, stop).

  Args:
    start: Start of the interval. Included in the range.
    stop: End of the interval. If not specified, `start` is treated as 0 and
      `start` value is used as `stop`. If specified, it is not included in the
      range if `step` is integer. When `step` is floating point, it may or may
      not be included.
    step: The difference between 2 consecutive values in the output range. It is
      recommended to use `linspace` instead of using non-integer values for
      `step`.
    dtype: Optional. Type of the resulting ndarray. Could be a python type, a
      NumPy type or a TensorFlow `DType`. If not provided, the largest type of
      `start`, `stop`, `step` is used.

  Raises:
    ValueError: If step is zero.
  """
  ...

@np_utils.np_doc('diag')
def diag(v, k=...): # -> Any | list[Unknown] | _basetuple | defaultdict[Unknown, Unknown] | ObjectProxy:
  """Raises an error if input is not 1- or 2-d."""
  ...

@np_utils.np_doc('diagonal')
def diagonal(a, offset=..., axis1=..., axis2=...):
  ...

@np_utils.np_doc('diagflat')
def diagflat(v, k=...): # -> Any | list[Unknown] | _basetuple | defaultdict[Unknown, Unknown] | ObjectProxy:
  ...

@np_utils.np_doc('all')
def all(a, axis=..., keepdims=...):
  ...

@np_utils.np_doc('any')
def any(a, axis=..., keepdims=...):
  ...

@np_utils.np_doc('compress')
def compress(condition, a, axis=...):
  ...

@np_utils.np_doc('copy')
def copy(a): # -> defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | Tensor | _basetuple:
  ...

@np_utils.np_doc('cumprod')
def cumprod(a, axis=..., dtype=...):
  ...

@np_utils.np_doc('cumsum')
def cumsum(a, axis=..., dtype=...):
  ...

@np_utils.np_doc('imag')
def imag(val):
  ...

_TO_INT_ = ...
_TO_FLOAT = ...
@np_utils.np_doc('size')
def size(x, axis=...): # -> Any | Tensor | Literal[1]:
  ...

@np_utils.np_doc('sum')
def sum(a, axis=..., dtype=..., keepdims=...):
  ...

@np_utils.np_doc('prod')
def prod(a, axis=..., dtype=..., keepdims=...):
  ...

@np_utils.np_doc('mean', unsupported_params=['out'])
def mean(a, axis=..., dtype=..., out=..., keepdims=...):
  ...

@np_utils.np_doc('amax', unsupported_params=['out'])
def amax(a, axis=..., out=..., keepdims=...):
  ...

@np_utils.np_doc('amin', unsupported_params=['out'])
def amin(a, axis=..., out=..., keepdims=...):
  ...

@np_utils.np_doc('var')
def var(a, axis=..., dtype=..., out=..., ddof=..., keepdims=...): # -> SparseTensor | IndexedSlices | Tensor | Any:
  ...

@np_utils.np_doc('std')
def std(a, axis=..., keepdims=...):
  ...

@np_utils.np_doc('ravel')
def ravel(a):
  ...

@np_utils.np_doc('real')
def real(val): # -> Tensor | Any:
  ...

@np_utils.np_doc('repeat')
def repeat(a, repeats, axis=...): # -> Any:
  ...

@np_utils.np_doc('around')
def around(a, decimals=...): # -> _dispatcher_for_real_div:
  ...

@np_utils.np_doc('reshape')
def reshape(a, newshape, order=...):
  """order argument can only b 'C' or 'F'."""
  ...

@np_utils.np_doc('expand_dims')
def expand_dims(a, axis):
  ...

@np_utils.np_doc('squeeze')
def squeeze(a, axis=...):
  ...

@np_utils.np_doc('transpose')
def transpose(a, axes=...):
  ...

@np_utils.np_doc('swapaxes')
def swapaxes(a, axis1, axis2):
  ...

@np_utils.np_doc('moveaxis')
def moveaxis(a, source, destination):
  """Raises ValueError if source, destination not in (-ndim(a), ndim(a))."""
  ...

@np_utils.np_doc('pad')
def pad(array, pad_width, mode, **kwargs):
  """Only supports modes 'constant', 'reflect' and 'symmetric' currently."""
  ...

@np_utils.np_doc('take')
def take(a, indices, axis=..., out=..., mode=...): # -> Any:
  """out argument is not supported, and default mode is clip."""
  ...

@np_utils.np_doc_only('where')
def where(condition, x=..., y=...):
  """Raises ValueError if exactly one of x or y is not None."""
  ...

@np_utils.np_doc('select')
def select(condlist, choicelist, default=...): # -> ndarray | defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple:
  ...

@np_utils.np_doc('shape', link=np_utils.Link('https://numpy.org/doc/1.18/reference/generated/numpy.shape.html'))
def shape(a): # -> Any | TensorShape:
  ...

@np_utils.np_doc('ndim', link=np_utils.NoLink())
def ndim(a): # -> Any | None:
  ...

@np_utils.np_doc('isscalar')
def isscalar(num): # -> Any:
  ...

@np_utils.np_doc('split')
def split(ary, indices_or_sections, axis=...):
  ...

vsplit = ...
hsplit = ...
dsplit = ...
@np_utils.np_doc('broadcast_to')
def broadcast_to(array, shape): # -> _dispatcher_for_broadcast_to | object:
  ...

@np_utils.np_doc('stack')
def stack(arrays, axis=...): # -> ndarray | defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple:
  ...

@np_utils.np_doc('hstack')
def hstack(tup): # -> Any | list[Unknown] | _basetuple | defaultdict[Unknown, Unknown] | ObjectProxy:
  ...

@np_utils.np_doc('vstack')
def vstack(tup): # -> defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy:
  ...

@np_utils.np_doc('dstack')
def dstack(tup): # -> defaultdict[Unknown, Unknown] | Any | list[Unknown] | ObjectProxy:
  ...

@np_utils.np_doc('atleast_1d')
def atleast_1d(*arys): # -> ndarray | Any | defaultdict[Unknown, Unknown] | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple | list[ndarray | Any | Unknown | defaultdict[Unknown, Unknown] | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple]:
  ...

@np_utils.np_doc('atleast_2d')
def atleast_2d(*arys): # -> ndarray | Any | defaultdict[Unknown, Unknown] | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple | list[ndarray | Any | Unknown | defaultdict[Unknown, Unknown] | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple]:
  ...

@np_utils.np_doc('atleast_3d')
def atleast_3d(*arys): # -> ndarray | Any | defaultdict[Unknown, Unknown] | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple | list[ndarray | Any | Unknown | defaultdict[Unknown, Unknown] | list[Unknown] | ObjectProxy | SparseTensor | IndexedSlices | _basetuple]:
  ...

@np_utils.np_doc('nonzero')
def nonzero(a):
  ...

@np_utils.np_doc('diag_indices')
def diag_indices(n, ndim=...): # -> tuple[Unknown, ...]:
  ...

@np_utils.np_doc('tri')
def tri(N, M=..., k=..., dtype=...): # -> SparseTensor | IndexedSlices | Tensor | Any | object:
  ...

@np_utils.np_doc('tril')
def tril(m, k=...):
  ...

@np_utils.np_doc('triu')
def triu(m, k=...):
  ...

@np_utils.np_doc('flip')
def flip(m, axis=...): # -> _dispatcher_for_reverse_v2 | object:
  ...

@np_utils.np_doc('flipud')
def flipud(m): # -> _dispatcher_for_reverse_v2 | object:
  ...

@np_utils.np_doc('fliplr')
def fliplr(m): # -> _dispatcher_for_reverse_v2 | object:
  ...

@np_utils.np_doc('roll')
def roll(a, shift, axis=...):
  ...

@np_utils.np_doc('rot90')
def rot90(m, k=..., axes=...): # -> _dispatcher_for_reverse_v2 | object:
  ...

@np_utils.np_doc('vander')
def vander(x, N=..., increasing=...):
  ...

@np_utils.np_doc('ix_')
def ix_(*args): # -> list[Unknown]:
  ...

@np_utils.np_doc('broadcast_arrays')
def broadcast_arrays(*args, **kwargs): # -> tuple[Unknown, ...] | list[Unknown | _dispatcher_for_broadcast_to | object]:
  ...

@np_utils.np_doc_only('sign')
def sign(x, out=..., where=..., **kwargs): # -> SparseTensor | IndexedSlices | Tensor | Any:
  ...

@np_utils.np_doc('take_along_axis')
def take_along_axis(arr, indices, axis): # -> Any | list[Unknown] | _basetuple | defaultdict[Unknown, Unknown] | ObjectProxy:
  ...

_SLICE_ERORR = ...
class _UpdateMethod(enum.Enum):
  UPDATE = ...
  ADD = ...
  MIN = ...
  MAX = ...


