"""
This type stub file was generated by pyright.
"""

from typing import Type
from tensorflow.core.function import trace_type
from tensorflow.core.protobuf import struct_pb2
from tensorflow.python.framework import type_spec
from tensorflow.python.util.tf_export import tf_export

"""A TensorSpec class."""
class DenseSpec(type_spec.TypeSpec):
  """Describes a dense object with shape, dtype, and name."""
  __slots__ = ...
  _component_specs = ...
  def __init__(self, shape, dtype=..., name=...) -> None:
    """Creates a TensorSpec.

    Args:
      shape: Value convertible to `tf.TensorShape`. The shape of the tensor.
      dtype: Value convertible to `tf.DType`. The type of the tensor values.
      name: Optional name for the Tensor.

    Raises:
      TypeError: If shape is not convertible to a `tf.TensorShape`, or dtype is
        not convertible to a `tf.DType`.
    """
    ...
  
  @property
  def shape(self): # -> TensorShape:
    """Returns the `TensorShape` that represents the shape of the tensor."""
    ...
  
  @property
  def dtype(self): # -> DType:
    """Returns the `dtype` of elements in the tensor."""
    ...
  
  @property
  def name(self): # -> None:
    """Returns the (optionally provided) name of the described tensor."""
    ...
  
  def is_compatible_with(self, spec_or_value): # -> bool:
    ...
  
  def __repr__(self): # -> str:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  


@tf_export("TensorSpec")
@type_spec.register("tf.TensorSpec")
class TensorSpec(DenseSpec, type_spec.BatchableTypeSpec, trace_type.Serializable):
  """Describes a tf.Tensor.

  Metadata for describing the `tf.Tensor` objects accepted or returned
  by some TensorFlow APIs.
  """
  __slots__ = ...
  @classmethod
  def experimental_type_proto(cls) -> Type[struct_pb2.TensorSpecProto]:
    """Returns the type of proto associated with TensorSpec serialization."""
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: struct_pb2.TensorSpecProto) -> TensorSpec:
    """Returns a TensorSpec instance based on the serialized proto."""
    ...
  
  def experimental_as_proto(self) -> struct_pb2.TensorSpecProto:
    """Returns a proto representation of the TensorSpec instance."""
    ...
  
  def is_compatible_with(self, spec_or_tensor):
    """Returns True if spec_or_tensor is compatible with this TensorSpec.

    Two tensors are considered compatible if they have the same dtype
    and their shapes are compatible (see `tf.TensorShape.is_compatible_with`).

    Args:
      spec_or_tensor: A tf.TensorSpec or a tf.Tensor

    Returns:
      True if spec_or_tensor is compatible with self.
    """
    ...
  
  @classmethod
  def from_spec(cls, spec, name=...): # -> Self@TensorSpec:
    """Returns a `TensorSpec` with the same shape and dtype as `spec`.

    >>> spec = tf.TensorSpec(shape=[8, 3], dtype=tf.int32, name="OriginalName")
    >>> tf.TensorSpec.from_spec(spec, "NewName")
    TensorSpec(shape=(8, 3), dtype=tf.int32, name='NewName')

    Args:
      spec: The `TypeSpec` used to create the new `TensorSpec`.
      name: The name for the new `TensorSpec`.  Defaults to `spec.name`.
    """
    ...
  
  @classmethod
  def from_tensor(cls, tensor, name=...): # -> TypeSpec:
    """Returns a `TensorSpec` that describes `tensor`.

    >>> tf.TensorSpec.from_tensor(tf.constant([1, 2, 3]))
    TensorSpec(shape=(3,), dtype=tf.int32, name=None)

    Args:
      tensor: The `tf.Tensor` that should be described.
      name: A name for the `TensorSpec`.  Defaults to `tensor.op.name`.

    Returns:
      A `TensorSpec` that describes `tensor`.
    """
    ...
  
  @property
  def value_type(self): # -> Type[Tensor]:
    """The Python type for values that are compatible with this TypeSpec."""
    ...
  


@type_spec.register("tf.BoundedTensorSpec")
class BoundedTensorSpec(TensorSpec, trace_type.Serializable):
  """A `TensorSpec` that specifies minimum and maximum values.

  Example usage:
  ```python
  spec = tensor_spec.BoundedTensorSpec((1, 2, 3), tf.float32, 0, (5, 5, 5))
  tf_minimum = tf.convert_to_tensor(spec.minimum, dtype=spec.dtype)
  tf_maximum = tf.convert_to_tensor(spec.maximum, dtype=spec.dtype)
  ```

  Bounds are meant to be inclusive. This is especially important for
  integer types. The following spec will be satisfied by tensors
  with values in the set {0, 1, 2}:
  ```python
  spec = tensor_spec.BoundedTensorSpec((3, 5), tf.int32, 0, 2)
  ```
  """
  __slots__ = ...
  def __init__(self, shape, dtype, minimum, maximum, name=...) -> None:
    """Initializes a new `BoundedTensorSpec`.

    Args:
      shape: Value convertible to `tf.TensorShape`. The shape of the tensor.
      dtype: Value convertible to `tf.DType`. The type of the tensor values.
      minimum: Number or sequence specifying the minimum element bounds
        (inclusive). Must be broadcastable to `shape`.
      maximum: Number or sequence specifying the maximum element bounds
        (inclusive). Must be broadcastable to `shape`.
      name: Optional string containing a semantic name for the corresponding
        array. Defaults to `None`.

    Raises:
      ValueError: If `minimum` or `maximum` are not provided or not
        broadcastable to `shape`.
      TypeError: If the shape is not an iterable or if the `dtype` is an invalid
        numpy dtype.
    """
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[struct_pb2.BoundedTensorSpecProto]:
    """Returns the type of proto associated with BoundedTensorSpec serialization."""
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: struct_pb2.BoundedTensorSpecProto) -> BoundedTensorSpec:
    """Returns a BoundedTensorSpec instance based on the serialized proto."""
    ...
  
  def experimental_as_proto(self) -> struct_pb2.BoundedTensorSpecProto:
    """Returns a proto representation of the BoundedTensorSpec instance."""
    ...
  
  @classmethod
  def from_spec(cls, spec): # -> TypeSpec:
    """Returns a `TensorSpec` with the same shape and dtype as `spec`.

    If `spec` is a `BoundedTensorSpec`, then the new spec's bounds are set to
    `spec.minimum` and `spec.maximum`; otherwise, the bounds are set to
    `spec.dtype.min` and `spec.dtype.max`.

    >>> spec = tf.TensorSpec(shape=[8, 3], dtype=tf.int32, name="x")
    >>> BoundedTensorSpec.from_spec(spec)
    BoundedTensorSpec(shape=(8, 3), dtype=tf.int32, name='x',
        minimum=array(-2147483648, dtype=int32),
        maximum=array(2147483647, dtype=int32))

    Args:
      spec: The `TypeSpec` used to create the new `BoundedTensorSpec`.
    """
    ...
  
  @property
  def minimum(self): # -> ndarray[Unknown, Unknown]:
    """Returns a NumPy array specifying the minimum bounds (inclusive)."""
    ...
  
  @property
  def maximum(self): # -> ndarray[Unknown, Unknown]:
    """Returns a NumPy array specifying the maximum bounds (inclusive)."""
    ...
  
  def __repr__(self): # -> str:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __reduce__(self): # -> tuple[Type[TypeSpec], tuple[Unknown, Unknown, ndarray[Unknown, Unknown], ndarray[Unknown, Unknown], Unknown]]:
    ...
  


