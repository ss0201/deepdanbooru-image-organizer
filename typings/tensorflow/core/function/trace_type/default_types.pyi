"""
This type stub file was generated by pyright.
"""

import weakref
from typing import Any, Dict as PythonDict, Hashable, Optional, Sequence, Tuple as PythonTuple, Type
from tensorflow.core.function.trace_type import default_types_pb2, serialization
from tensorflow.python.types import trace

"""TraceType implementations for common Python types."""
class Literal(trace.TraceType, serialization.Serializable):
  """Represents a Literal type like bool, int or string."""
  def __init__(self, value: Any) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[Literal]:
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedLiteral]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedLiteral) -> Literal:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedLiteral:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class Weakref(trace.TraceType):
  """Represents weakref of an arbitrary Python object.

  When a function argument is a custom class, instead of making a copy of it
  just for the sake of function cache, a weakref is instead kept to save memory.
  """
  def __init__(self, ref: weakref.ReferenceType) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[Weakref]:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class Tuple(trace.TraceType, serialization.Serializable):
  """Represents a tuple of TraceType objects."""
  def __init__(self, *components: trace.TraceType) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[Tuple]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedTuple]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedTuple) -> Tuple:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedTuple:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class List(trace.TraceType, serialization.Serializable):
  """Represents a list of TraceType objects."""
  def __init__(self, *components: trace.TraceType) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[Tuple]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedList]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedList) -> List:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedList:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class NamedTuple(trace.TraceType, serialization.Serializable):
  """Represents a NamedTuple of TraceType objects."""
  def __init__(self, type_name: str, attribute_names: PythonTuple[str], attributes: PythonTuple[trace.TraceType], placeholder_type: Optional[Type[Any]] = ...) -> None:
    ...
  
  @classmethod
  def from_type_and_attributes(cls, named_tuple_type: Any, attributes: PythonTuple[trace.TraceType]) -> NamedTuple:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[NamedTuple]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedNamedTuple]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedNamedTuple) -> NamedTuple:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedNamedTuple:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class Attrs(trace.TraceType):
  """Represents a class annotated by attr.s."""
  def __init__(self, type_name: str, attribute_names: PythonTuple[str], attributes: PythonTuple[trace.TraceType], placeholder_type: Optional[Type[Any]] = ...) -> None:
    ...
  
  @classmethod
  def from_type_and_attributes(cls, attrs_type: Any, attributes: PythonTuple[trace.TraceType]) -> Attrs:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional[Attrs]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedAttrs]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedAttrs) -> Attrs:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedAttrs:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class Dict(trace.TraceType, serialization.Serializable):
  """Represents a dictionary of TraceType objects.

  Attributes:
    mapping: A mapping from keys to corresponding TraceTypes of the dict values.
  """
  def __init__(self, mapping: PythonDict[Hashable, trace.TraceType]) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    """See base class."""
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[Dict]:
    """See base class."""
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedDict]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedDict) -> Dict:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedDict:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class Reference(trace.TraceType, serialization.Serializable):
  """Represents a resource with an identifier.

  Resource identifiers are useful to denote identical resources, that is,
  resources which are known at compilation time to point to the same thing.
  This information is useful in automatic control dependencies for instance,
  where ops using the same resource don't run concurrently.
  """
  def __init__(self, base: trace.TraceType, identifier: Hashable) -> None:
    ...
  
  def is_subtype_of(self, other: trace.TraceType) -> bool:
    ...
  
  def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional[Reference]:
    ...
  
  @classmethod
  def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedReference]:
    ...
  
  @classmethod
  def experimental_from_proto(cls, proto: default_types_pb2.SerializedReference) -> Reference:
    ...
  
  def experimental_as_proto(self) -> default_types_pb2.SerializedReference:
    ...
  
  def __eq__(self, other: Any) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __repr__(self): # -> str:
    ...
  


