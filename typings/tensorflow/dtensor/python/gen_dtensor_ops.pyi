"""
This type stub file was generated by pyright.
"""

from tensorflow.python.util import dispatch as _dispatch
from tensorflow.python.util.tf_export import tf_export

"""Python wrappers around TensorFlow ops.

This file is MACHINE GENERATED! Do not edit.
Original C++ source file: gen_dtensor_ops.cc
"""
@_dispatch.add_fallback_dispatch_list
@_dispatch.add_type_based_api_dispatcher
@tf_export('configure_and_initialize_global_tpu')
def configure_and_initialize_global_tpu(name=...): # -> _dispatcher_for_configure_and_initialize_global_tpu | object:
  r"""TODO: add doc.

  Args:
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `int32`.
  """
  ...

ConfigureAndInitializeGlobalTPU = ...
_dispatcher_for_configure_and_initialize_global_tpu = configure_and_initialize_global_tpu._tf_type_based_dispatcher.Dispatch
def configure_and_initialize_global_tpu_eager_fallback(name, ctx):
  ...

@_dispatch.add_fallback_dispatch_list
@_dispatch.add_type_based_api_dispatcher
@tf_export('copy_to_mesh')
def copy_to_mesh(input, layout, source_layout=..., name=...): # -> _dispatcher_for_copy_to_mesh | object:
  r"""TODO: add doc.

  Args:
    input: A `Tensor`.
    layout: A `string`.
    source_layout: An optional `string`. Defaults to `""`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `input`.
  """
  ...

CopyToMesh = ...
_dispatcher_for_copy_to_mesh = copy_to_mesh._tf_type_based_dispatcher.Dispatch
def copy_to_mesh_eager_fallback(input, layout, source_layout, name, ctx):
  ...

@_dispatch.add_fallback_dispatch_list
@_dispatch.add_type_based_api_dispatcher
@tf_export('d_tensor_restore_v2')
def d_tensor_restore_v2(prefix, tensor_names, shape_and_slices, input_shapes, input_layouts, dtypes, name=...): # -> _dispatcher_for_d_tensor_restore_v2 | object:
  r"""TODO: add doc.

  Args:
    prefix: A `Tensor` of type `string`.
    tensor_names: A `Tensor` of type `string`.
    shape_and_slices: A `Tensor` of type `string`.
    input_shapes: A list of shapes (each a `tf.TensorShape` or list of `ints`).
    input_layouts: A list of `strings`.
    dtypes: A list of `tf.DTypes` that has length `>= 1`.
    name: A name for the operation (optional).

  Returns:
    A list of `Tensor` objects of type `dtypes`.
  """
  ...

DTensorRestoreV2 = ...
_dispatcher_for_d_tensor_restore_v2 = d_tensor_restore_v2._tf_type_based_dispatcher.Dispatch
def d_tensor_restore_v2_eager_fallback(prefix, tensor_names, shape_and_slices, input_shapes, input_layouts, dtypes, name, ctx):
  ...

@_dispatch.add_fallback_dispatch_list
@_dispatch.add_type_based_api_dispatcher
@tf_export('d_tensor_set_global_tpu_array')
def d_tensor_set_global_tpu_array(topology, name=...): # -> _dispatcher_for_d_tensor_set_global_tpu_array | object | None:
  r"""TODO: add doc.

  Args:
    topology: A `Tensor` of type `string`.
    name: A name for the operation (optional).

  Returns:
    The created Operation.
  """
  ...

DTensorSetGlobalTPUArray = ...
_dispatcher_for_d_tensor_set_global_tpu_array = d_tensor_set_global_tpu_array._tf_type_based_dispatcher.Dispatch
def d_tensor_set_global_tpu_array_eager_fallback(topology, name, ctx): # -> None:
  ...

@_dispatch.add_fallback_dispatch_list
@_dispatch.add_type_based_api_dispatcher
@tf_export('d_tensor_sharded_prefix')
def d_tensor_sharded_prefix(prefix, tensor_names, shape_and_slices, mesh, layouts, tensors, name=...): # -> _dispatcher_for_d_tensor_sharded_prefix | object:
  r"""TODO: add doc.

  Args:
    prefix: A `Tensor` of type `string`.
    tensor_names: A `Tensor` of type `string`.
    shape_and_slices: A `Tensor` of type `string`.
    mesh: A `Tensor` of type `string`.
    layouts: A `Tensor` of type `string`.
    tensors: A list of `Tensor` objects.
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `string`.
  """
  ...

DTensorShardedPrefix = ...
_dispatcher_for_d_tensor_sharded_prefix = d_tensor_sharded_prefix._tf_type_based_dispatcher.Dispatch
def d_tensor_sharded_prefix_eager_fallback(prefix, tensor_names, shape_and_slices, mesh, layouts, tensors, name, ctx):
  ...

@_dispatch.add_fallback_dispatch_list
@_dispatch.add_type_based_api_dispatcher
@tf_export('relayout')
def relayout(input, layout, name=...): # -> _dispatcher_for_relayout | object:
  r"""TODO: add doc.

  Args:
    input: A `Tensor`.
    layout: A `string`.
    name: A name for the operation (optional).

  Returns:
    A `Tensor`. Has the same type as `input`.
  """
  ...

Relayout = ...
_dispatcher_for_relayout = relayout._tf_type_based_dispatcher.Dispatch
def relayout_eager_fallback(input, layout, name, ctx):
  ...

@_dispatch.add_fallback_dispatch_list
@_dispatch.add_type_based_api_dispatcher
@tf_export('shutdown_tpu_system')
def shutdown_tpu_system(name=...): # -> _dispatcher_for_shutdown_tpu_system | object:
  r"""TODO: add doc.

  Args:
    name: A name for the operation (optional).

  Returns:
    A `Tensor` of type `bool`.
  """
  ...

ShutdownTPUSystem = ...
_dispatcher_for_shutdown_tpu_system = shutdown_tpu_system._tf_type_based_dispatcher.Dispatch
def shutdown_tpu_system_eager_fallback(name, ctx):
  ...

