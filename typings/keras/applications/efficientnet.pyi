"""
This type stub file was generated by pyright.
"""

from tensorflow.python.util.tf_export import keras_export

"""EfficientNet models for Keras.

Reference:
  - [EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks](
      https://arxiv.org/abs/1905.11946) (ICML 2019)
"""
BASE_WEIGHTS_PATH = ...
WEIGHTS_HASHES = ...
DEFAULT_BLOCKS_ARGS = ...
CONV_KERNEL_INITIALIZER = ...
DENSE_KERNEL_INITIALIZER = ...
layers = ...
BASE_DOCSTRING = ...
IMAGENET_STDDEV_RGB = ...
def EfficientNet(width_coefficient, depth_coefficient, default_size, dropout_rate=..., drop_connect_rate=..., depth_divisor=..., activation=..., blocks_args=..., model_name=..., include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=...): # -> Model:
    """Instantiates the EfficientNet architecture using given scaling coefficients.

    Args:
      width_coefficient: float, scaling coefficient for network width.
      depth_coefficient: float, scaling coefficient for network depth.
      default_size: integer, default input image size.
      dropout_rate: float, dropout rate before final classifier layer.
      drop_connect_rate: float, dropout rate at skip connections.
      depth_divisor: integer, a unit of network width.
      activation: activation function.
      blocks_args: list of dicts, parameters to construct block modules.
      model_name: string, model name.
      include_top: whether to include the fully-connected
          layer at the top of the network.
      weights: one of `None` (random initialization),
            'imagenet' (pre-training on ImageNet),
            or the path to the weights file to be loaded.
      input_tensor: optional Keras tensor
          (i.e. output of `layers.Input()`)
          to use as image input for the model.
      input_shape: optional shape tuple, only to be specified
          if `include_top` is False.
          It should have exactly 3 inputs channels.
      pooling: optional pooling mode for feature extraction
          when `include_top` is `False`.
          - `None` means that the output of the model will be
              the 4D tensor output of the
              last convolutional layer.
          - `avg` means that global average pooling
              will be applied to the output of the
              last convolutional layer, and thus
              the output of the model will be a 2D tensor.
          - `max` means that global max pooling will
              be applied.
      classes: optional number of classes to classify images
          into, only to be specified if `include_top` is True, and
          if no `weights` argument is specified.
      classifier_activation: A `str` or callable. The activation function to use
          on the "top" layer. Ignored unless `include_top=True`. Set
          `classifier_activation=None` to return the logits of the "top" layer.

    Returns:
      A `keras.Model` instance.

    Raises:
      ValueError: in case of invalid argument for `weights`,
        or invalid input shape.
      ValueError: if `classifier_activation` is not `softmax` or `None` when
        using a pretrained top layer.
    """
    ...

def block(inputs, activation=..., drop_rate=..., name=..., filters_in=..., filters_out=..., kernel_size=..., strides=..., expand_ratio=..., se_ratio=..., id_skip=...): # -> Any:
    """An inverted residual block.

    Args:
        inputs: input tensor.
        activation: activation function.
        drop_rate: float between 0 and 1, fraction of the input units to drop.
        name: string, block label.
        filters_in: integer, the number of input filters.
        filters_out: integer, the number of output filters.
        kernel_size: integer, the dimension of the convolution window.
        strides: integer, the stride of the convolution.
        expand_ratio: integer, scaling coefficient for the input filters.
        se_ratio: float between 0 and 1, fraction to squeeze the input filters.
        id_skip: boolean.

    Returns:
        output tensor for the block.
    """
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB0", "keras.applications.EfficientNetB0")
def EfficientNetB0(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB1", "keras.applications.EfficientNetB1")
def EfficientNetB1(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB2", "keras.applications.EfficientNetB2")
def EfficientNetB2(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB3", "keras.applications.EfficientNetB3")
def EfficientNetB3(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB4", "keras.applications.EfficientNetB4")
def EfficientNetB4(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB5", "keras.applications.EfficientNetB5")
def EfficientNetB5(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB6", "keras.applications.EfficientNetB6")
def EfficientNetB6(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.EfficientNetB7", "keras.applications.EfficientNetB7")
def EfficientNetB7(include_top=..., weights=..., input_tensor=..., input_shape=..., pooling=..., classes=..., classifier_activation=..., **kwargs): # -> Model:
    ...

@keras_export("keras.applications.efficientnet.preprocess_input")
def preprocess_input(x, data_format=...):
    """A placeholder method for backward compatibility.

    The preprocessing logic has been included in the efficientnet model
    implementation. Users are no longer required to call this method to
    normalize the input data. This method does nothing and only kept as a
    placeholder to align the API surface between old and new version of model.

    Args:
      x: A floating point `numpy.array` or a `tf.Tensor`.
      data_format: Optional data format of the image tensor/array. Defaults to
        None, in which case the global setting
        `tf.keras.backend.image_data_format()` is used (unless you changed it,
        it defaults to "channels_last").{mode}

    Returns:
      Unchanged `numpy.array` or `tf.Tensor`.
    """
    ...

@keras_export("keras.applications.efficientnet.decode_predictions")
def decode_predictions(preds, top=...): # -> list[Unknown]:
    ...

