"""
This type stub file was generated by pyright.
"""

import os
import threading
import weakref
import tensorflow.compat.v2 as tf
from keras.utils import tf_contextlib
from tensorflow.python.util.tf_export import keras_export
from tensorflow.tools.docs import doc_controls

"""Keras backend API."""
py_all = ...
py_sum = ...
py_any = ...
_GRAPH = ...
_CURRENT_SCRATCH_GRAPH = ...
class SessionLocal(threading.local):
    def __init__(self) -> None:
        ...
    


_SESSION = ...
PER_GRAPH_OBJECT_NAME_UIDS = ...
OBSERVED_NAMES = ...
class _DummyEagerGraph(threading.local):
    """_DummyEagerGraph provides a thread local `key` attribute.

    We can't use threading.local directly, i.e. without subclassing, because
    gevent monkey patches threading.local and its version does not support
    weak references.
    """
    class _WeakReferencableClass:
        """This dummy class is needed for two reasons.

        - We need something that supports weak references. Basic types like
        string and ints don't.
        - We need something whose hash and equality are based on object identity
        to make sure they are treated as different keys to
        _GRAPH_LEARNING_PHASES.

        An empty Python class satisfies both of these requirements.
        """
        ...
    
    
    def __init__(self) -> None:
        ...
    


_DUMMY_EAGER_GRAPH = ...
_MANUAL_VAR_INIT = ...
_LOCAL_DEVICES = ...
epsilon = ...
floatx = ...
image_data_format = ...
set_epsilon = ...
set_floatx = ...
set_image_data_format = ...
@keras_export("keras.backend.backend")
@doc_controls.do_not_generate_docs
def backend(): # -> Literal['tensorflow']:
    """Publicly accessible method for determining the current backend.

    Only exists for API compatibility with multi-backend Keras.

    Returns:
        The string "tensorflow".
    """
    ...

@keras_export("keras.backend.cast_to_floatx")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def cast_to_floatx(x): # -> ndarray[Unknown, Unknown]:
    """Cast a Numpy array to the default Keras float type.

    Args:
        x: Numpy array or TensorFlow tensor.

    Returns:
        The same array (Numpy array if `x` was a Numpy array, or TensorFlow
        tensor if `x` was a tensor), cast to its new type.

    Example:

    >>> tf.keras.backend.floatx()
    'float32'
    >>> arr = np.array([1.0, 2.0], dtype='float64')
    >>> arr.dtype
    dtype('float64')
    >>> new_arr = cast_to_floatx(arr)
    >>> new_arr
    array([1.,  2.], dtype=float32)
    >>> new_arr.dtype
    dtype('float32')

    """
    ...

@keras_export("keras.backend.get_uid")
def get_uid(prefix=...):
    """Associates a string prefix with an integer counter in a TensorFlow graph.

    Args:
      prefix: String prefix to index.

    Returns:
      Unique integer ID.

    Example:

    >>> get_uid('dense')
    1
    >>> get_uid('dense')
    2

    """
    ...

@keras_export("keras.backend.reset_uids")
def reset_uids(): # -> None:
    """Resets graph identifiers."""
    ...

@keras_export("keras.backend.clear_session")
def clear_session(): # -> None:
    """Resets all state generated by Keras.

    Keras manages a global state, which it uses to implement the Functional
    model-building API and to uniquify autogenerated layer names.

    If you are creating many models in a loop, this global state will consume
    an increasing amount of memory over time, and you may want to clear it.
    Calling `clear_session()` releases the global state: this helps avoid
    clutter from old models and layers, especially when memory is limited.

    Example 1: calling `clear_session()` when creating models in a loop

    ```python
    for _ in range(100):
      # Without `clear_session()`, each iteration of this loop will
      # slightly increase the size of the global state managed by Keras
      model = tf.keras.Sequential([
          tf.keras.layers.Dense(10) for _ in range(10)])

    for _ in range(100):
      # With `clear_session()` called at the beginning,
      # Keras starts with a blank state at each iteration
      # and memory consumption is constant over time.
      tf.keras.backend.clear_session()
      model = tf.keras.Sequential([
          tf.keras.layers.Dense(10) for _ in range(10)])
    ```

    Example 2: resetting the layer name generation counter

    >>> import tensorflow as tf
    >>> layers = [tf.keras.layers.Dense(10) for _ in range(10)]
    >>> new_layer = tf.keras.layers.Dense(10)
    >>> print(new_layer.name)
    dense_10
    >>> tf.keras.backend.set_learning_phase(1)
    >>> print(tf.keras.backend.learning_phase())
    1
    >>> tf.keras.backend.clear_session()
    >>> new_layer = tf.keras.layers.Dense(10)
    >>> print(new_layer.name)
    dense
    """
    ...

@keras_export("keras.backend.manual_variable_initialization")
@doc_controls.do_not_generate_docs
def manual_variable_initialization(value): # -> None:
    """Sets the manual variable initialization flag.

    This boolean flag determines whether
    variables should be initialized
    as they are instantiated (default), or if
    the user should handle the initialization
    (e.g. via `tf.compat.v1.initialize_all_variables()`).

    Args:
        value: Python boolean.
    """
    ...

@keras_export("keras.backend.learning_phase")
@doc_controls.do_not_generate_docs
def learning_phase(): # -> None:
    """Returns the learning phase flag.

    The learning phase flag is a bool tensor (0 = test, 1 = train)
    to be passed as input to any Keras function
    that uses a different behavior at train time and test time.

    Returns:
        Learning phase (scalar integer tensor or Python integer).
    """
    ...

def global_learning_phase_is_set(): # -> bool:
    ...

def symbolic_learning_phase(): # -> None:
    ...

@keras_export("keras.backend.set_learning_phase")
@doc_controls.do_not_generate_docs
def set_learning_phase(value): # -> None:
    """Sets the learning phase to a fixed value.

    The backend learning phase affects any code that calls
    `backend.learning_phase()`
    In particular, all Keras built-in layers use the learning phase as the
    default for the `training` arg to `Layer.__call__`.

    User-written layers and models can achieve the same behavior with code that
    looks like:

    ```python
      def call(self, inputs, training=None):
        if training is None:
          training = backend.learning_phase()
    ```

    Args:
        value: Learning phase value, either 0 or 1 (integers).
               0 = test, 1 = train

    Raises:
        ValueError: if `value` is neither `0` nor `1`.
    """
    ...

def deprecated_internal_set_learning_phase(value): # -> None:
    """A deprecated internal implementation of set_learning_phase.

    This method is an internal-only version of `set_learning_phase` that
    does not raise a deprecation error. It is required because
    saved_model needs to keep working with user code that uses the deprecated
    learning phase methods until those APIs are fully removed from the public
    API.

    Specifically SavedModel saving needs to make sure the learning phase is 0
    during tracing even if users overwrote it to a different value.

    But, we don't want to raise deprecation warnings for users when savedmodel
    sets learning phase just for compatibility with code that relied on
    explicitly setting the learning phase for other values.

    Args:
        value: Learning phase value, either 0 or 1 (integers).
            0 = test, 1 = train

    Raises:
        ValueError: if `value` is neither `0` nor `1`.
    """
    ...

@keras_export("keras.backend.learning_phase_scope")
@tf_contextlib.contextmanager
@doc_controls.do_not_generate_docs
def learning_phase_scope(value): # -> Generator[None, None, None]:
    """Provides a scope within which the learning phase is equal to `value`.

    The learning phase gets restored to its original value upon exiting the
    scope.

    Args:
       value: Learning phase value, either 0 or 1 (integers).
              0 = test, 1 = train

    Yields:
      None.

    Raises:
       ValueError: if `value` is neither `0` nor `1`.
    """
    ...

@tf_contextlib.contextmanager
def deprecated_internal_learning_phase_scope(value): # -> Generator[None, None, None]:
    """An internal-only version of `learning_phase_scope`.

    Unlike the public method, this method does not raise a deprecation warning.
    This is needed because saved model saving needs to set learning phase
    to maintain compatibility
    with code that sets/gets the learning phase, but saved model
    saving itself shouldn't raise a deprecation warning.

    We can get rid of this method and its usages when the public API is
    removed.

    Args:
        value: Learning phase value, either 0 or 1 (integers).
            0 = test, 1 = train

    Yields:
        None.

    Raises:
        ValueError: if `value` is neither `0` nor `1`.
    """
    ...

@tf_contextlib.contextmanager
def eager_learning_phase_scope(value): # -> Generator[None, None, None]:
    """Internal scope that sets the learning phase in eager / tf.function only.

    Args:
        value: Learning phase value, either 0 or 1 (integers).
               0 = test, 1 = train

    Yields:
      None.

    Raises:
       ValueError: if `value` is neither `0` nor `1`.
    """
    ...

@keras_export(v1=["keras.backend.get_session"])
def get_session(op_input_list=...): # -> None:
    """Returns the TF session to be used by the backend.

    If a default TensorFlow session is available, we will return it.

    Else, we will return the global Keras session assuming it matches
    the current graph.

    If no global Keras session exists at this point:
    we will create a new global session.

    Note that you can manually set the global session
    via `K.set_session(sess)`.

    Args:
        op_input_list: An option sequence of tensors or ops, which will be used
          to determine the current graph. Otherwise the default graph will be
          used.

    Returns:
        A TensorFlow session.
    """
    ...

def get_graph(): # -> Any:
    ...

@keras_export(v1=["keras.backend.set_session"])
def set_session(session): # -> None:
    """Sets the global TensorFlow session.

    Args:
        session: A TF Session.
    """
    ...

def get_default_session_config():
    ...

def get_default_graph_uid_map(): # -> defaultdict[Unknown, int]:
    ...

class _TfDeviceCaptureOp:
    """Class for capturing the TF device scope."""
    def __init__(self) -> None:
        ...
    


@keras_export("keras.backend.is_sparse")
@doc_controls.do_not_generate_docs
def is_sparse(tensor): # -> bool:
    """Returns whether a tensor is a sparse tensor.

    Args:
        tensor: A tensor instance.

    Returns:
        A boolean.

    Example:


    >>> a = tf.keras.backend.placeholder((2, 2), sparse=False)
    >>> print(tf.keras.backend.is_sparse(a))
    False
    >>> b = tf.keras.backend.placeholder((2, 2), sparse=True)
    >>> print(tf.keras.backend.is_sparse(b))
    True

    """
    ...

@keras_export("keras.backend.to_dense")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def to_dense(tensor):
    """Converts a sparse tensor into a dense tensor and returns it.

    Args:
        tensor: A tensor instance (potentially sparse).

    Returns:
        A dense tensor.

    Examples:


    >>> b = tf.keras.backend.placeholder((2, 2), sparse=True)
    >>> print(tf.keras.backend.is_sparse(b))
    True
    >>> c = tf.keras.backend.to_dense(b)
    >>> print(tf.keras.backend.is_sparse(c))
    False

    """
    ...

@keras_export("keras.backend.name_scope", v1=[])
@doc_controls.do_not_generate_docs
def name_scope(name):
    """A context manager for use when defining a Python op.

    This context manager pushes a name scope, which will make the name of all
    operations added within it have a prefix.

    For example, to define a new Python op called `my_op`:


    def my_op(a):
      with tf.name_scope("MyOp") as scope:
        a = tf.convert_to_tensor(a, name="a")
        # Define some computation that uses `a`.
        return foo_op(..., name=scope)


    When executed, the Tensor `a` will have the name `MyOp/a`.

    Args:
      name: The prefix to use on all names created within the name scope.

    Returns:
      Name scope context manager.
    """
    ...

_v1_name_scope = ...
@keras_export("keras.backend.variable")
@doc_controls.do_not_generate_docs
def variable(value, dtype=..., name=..., constraint=...):
    """Instantiates a variable and returns it.

    Args:
        value: Numpy array, initial value of the tensor.
        dtype: Tensor type.
        name: Optional name string for the tensor.
        constraint: Optional projection function to be
            applied to the variable after an optimizer update.

    Returns:
        A variable instance (with Keras metadata included).

    Examples:

    >>> val = np.array([[1, 2], [3, 4]])
    >>> kvar = tf.keras.backend.variable(value=val, dtype='float64',
    ...                                  name='example_var')
    >>> tf.keras.backend.dtype(kvar)
    'float64'
    >>> print(kvar)
    <tf.Variable 'example_var:...' shape=(2, 2) dtype=float64, numpy=
      array([[1., 2.],
             [3., 4.]])>

    """
    ...

def track_tf_optimizer(tf_optimizer): # -> None:
    """Tracks the given TF optimizer for initialization of its variables."""
    ...

@keras_export("keras.__internal__.backend.track_variable", v1=[])
def track_variable(v): # -> None:
    """Tracks the given variable for initialization."""
    ...

def observe_object_name(name): # -> None:
    """Observe a name and make sure it won't be used by `unique_object_name`."""
    ...

def unique_object_name(name, name_uid_map=..., avoid_names=..., namespace=..., zero_based=..., avoid_observed_names=...):
    """Makes a object name (or arbitrary string) unique within a TensorFlow graph.

    Args:
      name: String name to make unique.
      name_uid_map: An optional defaultdict(int) to use when creating unique
        names. If None (default), uses a per-Graph dictionary.
      avoid_names: An optional set or dict with names which should not be used.
        If None (default), don't avoid any names unless `avoid_observed_names`
        is True.
      namespace: Gets a name which is unique within the (graph, namespace).
        Layers which are not Networks use a blank namespace and so get
        graph-global names.
      zero_based: If True, name sequences start with no suffix (e.g. "dense",
        "dense_1"). If False, naming is one-based ("dense_1", "dense_2").
      avoid_observed_names: If True, avoid any names that have been observed by
        `backend.observe_object_name`.

    Returns:
      Unique string name.

    Example:


    unique_object_name('dense')  # dense_1
    unique_object_name('dense')  # dense_2

    """
    ...

@keras_export("keras.backend.constant")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def constant(value, dtype=..., shape=..., name=...):
    """Creates a constant tensor.

    Args:
        value: A constant value (or list)
        dtype: The type of the elements of the resulting tensor.
        shape: Optional dimensions of resulting tensor.
        name: Optional name for the tensor.

    Returns:
        A Constant Tensor.
    """
    ...

@keras_export("keras.backend.is_keras_tensor")
def is_keras_tensor(x): # -> bool:
    """Returns whether `x` is a Keras tensor.

    A "Keras tensor" is a tensor that was returned by a Keras layer,
    (`Layer` class) or by `Input`.

    Args:
        x: A candidate tensor.

    Returns:
        A boolean: Whether the argument is a Keras tensor.

    Raises:
        ValueError: In case `x` is not a symbolic tensor.

    Examples:

    >>> np_var = np.array([1, 2])
    >>> # A numpy array is not a symbolic tensor.
    >>> tf.keras.backend.is_keras_tensor(np_var)
    Traceback (most recent call last):
    ...
    ValueError: Unexpectedly found an instance of type
    `<class 'numpy.ndarray'>`.
    Expected a symbolic tensor instance.
    >>> keras_var = tf.keras.backend.variable(np_var)
    >>> # A variable created with the keras backend is not a Keras tensor.
    >>> tf.keras.backend.is_keras_tensor(keras_var)
    False
    >>> keras_placeholder = tf.keras.backend.placeholder(shape=(2, 4, 5))
    >>> # A placeholder is a Keras tensor.
    >>> tf.keras.backend.is_keras_tensor(keras_placeholder)
    True
    >>> keras_input = tf.keras.layers.Input([10])
    >>> # An Input is a Keras tensor.
    >>> tf.keras.backend.is_keras_tensor(keras_input)
    True
    >>> keras_layer_output = tf.keras.layers.Dense(10)(keras_input)
    >>> # Any Keras layer output is a Keras tensor.
    >>> tf.keras.backend.is_keras_tensor(keras_layer_output)
    True

    """
    ...

@keras_export("keras.backend.placeholder")
@doc_controls.do_not_generate_docs
def placeholder(shape=..., ndim=..., dtype=..., sparse=..., name=..., ragged=...): # -> list[Unknown]:
    """Instantiates a placeholder tensor and returns it.

    Args:
        shape: Shape of the placeholder
            (integer tuple, may include `None` entries).
        ndim: Number of axes of the tensor.
            At least one of {`shape`, `ndim`} must be specified.
            If both are specified, `shape` is used.
        dtype: Placeholder type.
        sparse: Boolean, whether the placeholder should have a sparse type.
        name: Optional name string for the placeholder.
        ragged: Boolean, whether the placeholder should have a ragged type.
            In this case, values of 'None' in the 'shape' argument represent
            ragged dimensions. For more information about RaggedTensors, see
            this [guide](https://www.tensorflow.org/guide/ragged_tensor).

    Raises:
        ValueError: If called with sparse = True and ragged = True.

    Returns:
        Tensor instance (with Keras metadata included).

    Examples:


    >>> input_ph = tf.keras.backend.placeholder(shape=(2, 4, 5))
    >>> input_ph
    <KerasTensor: shape=(2, 4, 5) dtype=float32 (created by layer ...)>

    """
    ...

def is_placeholder(x): # -> bool:
    """Returns whether `x` is a placeholder.

    Args:
        x: A candidate placeholder.

    Returns:
        Boolean.
    """
    ...

@keras_export("keras.backend.shape")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def shape(x):
    """Returns the symbolic shape of a tensor or variable.

    Args:
        x: A tensor or variable.

    Returns:
        A symbolic shape (which is itself a tensor).

    Examples:

    >>> val = np.array([[1, 2], [3, 4]])
    >>> kvar = tf.keras.backend.variable(value=val)
    >>> tf.keras.backend.shape(kvar)
    <tf.Tensor: shape=(2,), dtype=int32, numpy=array([2, 2], dtype=int32)>
    >>> input = tf.keras.backend.placeholder(shape=(2, 4, 5))
    >>> tf.keras.backend.shape(input)
    <KerasTensor: shape=(3,) dtype=int32 inferred_value=[2, 4, 5] ...>

    """
    ...

@keras_export("keras.backend.int_shape")
@doc_controls.do_not_generate_docs
def int_shape(x): # -> tuple[Unknown, ...] | None:
    """Returns the shape of tensor or variable as a tuple of int or None entries.

    Args:
        x: Tensor or variable.

    Returns:
        A tuple of integers (or None entries).

    Examples:

    >>> input = tf.keras.backend.placeholder(shape=(2, 4, 5))
    >>> tf.keras.backend.int_shape(input)
    (2, 4, 5)
    >>> val = np.array([[1, 2], [3, 4]])
    >>> kvar = tf.keras.backend.variable(value=val)
    >>> tf.keras.backend.int_shape(kvar)
    (2, 2)

    """
    ...

@keras_export("keras.backend.ndim")
@doc_controls.do_not_generate_docs
def ndim(x):
    """Returns the number of axes in a tensor, as an integer.

    Args:
        x: Tensor or variable.

    Returns:
        Integer (scalar), number of axes.

    Examples:


    >>> input = tf.keras.backend.placeholder(shape=(2, 4, 5))
    >>> val = np.array([[1, 2], [3, 4]])
    >>> kvar = tf.keras.backend.variable(value=val)
    >>> tf.keras.backend.ndim(input)
    3
    >>> tf.keras.backend.ndim(kvar)
    2

    """
    ...

@keras_export("keras.backend.dtype")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def dtype(x):
    """Returns the dtype of a Keras tensor or variable, as a string.

    Args:
        x: Tensor or variable.

    Returns:
        String, dtype of `x`.

    Examples:

    >>> tf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5)))
    'float32'
    >>> tf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5),
    ...                                                     dtype='float32'))
    'float32'
    >>> tf.keras.backend.dtype(tf.keras.backend.placeholder(shape=(2,4,5),
    ...                                                     dtype='float64'))
    'float64'
    >>> kvar = tf.keras.backend.variable(np.array([[1, 2], [3, 4]]))
    >>> tf.keras.backend.dtype(kvar)
    'float32'
    >>> kvar = tf.keras.backend.variable(np.array([[1, 2], [3, 4]]),
    ...                                  dtype='float32')
    >>> tf.keras.backend.dtype(kvar)
    'float32'

    """
    ...

@doc_controls.do_not_generate_docs
def dtype_numpy(x):
    """Returns the numpy dtype of a Keras tensor or variable.

    Args:
        x: Tensor or variable.

    Returns:
        numpy.dtype, dtype of `x`.
    """
    ...

@keras_export("keras.backend.eval")
@doc_controls.do_not_generate_docs
def eval(x):
    """Evaluates the value of a variable.

    Args:
        x: A variable.

    Returns:
        A Numpy array.

    Examples:

    >>> kvar = tf.keras.backend.variable(np.array([[1, 2], [3, 4]]),
    ...                                  dtype='float32')
    >>> tf.keras.backend.eval(kvar)
    array([[1.,  2.],
           [3.,  4.]], dtype=float32)

    """
    ...

@keras_export("keras.backend.zeros")
@doc_controls.do_not_generate_docs
def zeros(shape, dtype=..., name=...):
    """Instantiates an all-zeros variable and returns it.

    Args:
        shape: Tuple or list of integers, shape of returned Keras variable
        dtype: data type of returned Keras variable
        name: name of returned Keras variable

    Returns:
        A variable (including Keras metadata), filled with `0.0`.
        Note that if `shape` was symbolic, we cannot return a variable,
        and will return a dynamically-shaped tensor instead.

    Example:

    >>> kvar = tf.keras.backend.zeros((3,4))
    >>> tf.keras.backend.eval(kvar)
    array([[0.,  0.,  0.,  0.],
           [0.,  0.,  0.,  0.],
           [0.,  0.,  0.,  0.]], dtype=float32)
    >>> A = tf.constant([1,2,3])
    >>> kvar2 = tf.keras.backend.zeros(A.shape) # [0., 0., 0.]
    >>> tf.keras.backend.eval(kvar2)
    array([0., 0., 0.], dtype=float32)
    >>> kvar3 = tf.keras.backend.zeros(A.shape,dtype=tf.int32)
    >>> tf.keras.backend.eval(kvar3)
    array([0, 0, 0], dtype=int32)
    >>> kvar4 = tf.keras.backend.zeros([2,3])
    >>> tf.keras.backend.eval(kvar4)
    array([[0., 0., 0.],
           [0., 0., 0.]], dtype=float32)

    """
    ...

@keras_export("keras.backend.ones")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def ones(shape, dtype=..., name=...):
    """Instantiates an all-ones variable and returns it.

    Args:
        shape: Tuple of integers, shape of returned Keras variable.
        dtype: String, data type of returned Keras variable.
        name: String, name of returned Keras variable.

    Returns:
        A Keras variable, filled with `1.0`.
        Note that if `shape` was symbolic, we cannot return a variable,
        and will return a dynamically-shaped tensor instead.

    Example:


    >>> kvar = tf.keras.backend.ones((3,4))
    >>> tf.keras.backend.eval(kvar)
    array([[1.,  1.,  1.,  1.],
           [1.,  1.,  1.,  1.],
           [1.,  1.,  1.,  1.]], dtype=float32)

    """
    ...

@keras_export("keras.backend.eye")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def eye(size, dtype=..., name=...):
    """Instantiate an identity matrix and returns it.

    Args:
        size: Integer, number of rows/columns.
        dtype: String, data type of returned Keras variable.
        name: String, name of returned Keras variable.

    Returns:
        A Keras variable, an identity matrix.

    Example:


    >>> kvar = tf.keras.backend.eye(3)
    >>> tf.keras.backend.eval(kvar)
    array([[1.,  0.,  0.],
           [0.,  1.,  0.],
           [0.,  0.,  1.]], dtype=float32)


    """
    ...

@keras_export("keras.backend.zeros_like")
@doc_controls.do_not_generate_docs
def zeros_like(x, dtype=..., name=...):
    """Instantiates an all-zeros variable of the same shape as another tensor.

    Args:
        x: Keras variable or Keras tensor.
        dtype: dtype of returned Keras variable.
               `None` uses the dtype of `x`.
        name: name for the variable to create.

    Returns:
        A Keras variable with the shape of `x` filled with zeros.

    Example:

    ```python
    kvar = tf.keras.backend.variable(np.random.random((2,3)))
    kvar_zeros = tf.keras.backend.zeros_like(kvar)
    K.eval(kvar_zeros)
    # array([[ 0.,  0.,  0.], [ 0.,  0.,  0.]], dtype=float32)
    ```
    """
    ...

@keras_export("keras.backend.ones_like")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def ones_like(x, dtype=..., name=...):
    """Instantiates an all-ones variable of the same shape as another tensor.

    Args:
        x: Keras variable or tensor.
        dtype: String, dtype of returned Keras variable.
             None uses the dtype of x.
        name: String, name for the variable to create.

    Returns:
        A Keras variable with the shape of x filled with ones.

    Example:

    >>> kvar = tf.keras.backend.variable(np.random.random((2,3)))
    >>> kvar_ones = tf.keras.backend.ones_like(kvar)
    >>> tf.keras.backend.eval(kvar_ones)
    array([[1.,  1.,  1.],
           [1.,  1.,  1.]], dtype=float32)

    """
    ...

def identity(x, name=...):
    """Returns a tensor with the same content as the input tensor.

    Args:
        x: The input tensor.
        name: String, name for the variable to create.

    Returns:
        A tensor of the same shape, type and content.
    """
    ...

_USE_GENERATOR_FOR_RNG = ...
_SEED_GENERATOR = ...
@keras_export("keras.backend.experimental.is_tf_random_generator_enabled", v1=[])
def is_tf_random_generator_enabled(): # -> Literal[False]:
    """Check whether `tf.random.Generator` is used for RNG in Keras.

    Compared to existing TF stateful random ops, `tf.random.Generator` uses
    `tf.Variable` and stateless random ops to generate random numbers,
    which leads to better reproducibility in distributed training.
    Note enabling it might introduce some breakage to existing code,
    by producing differently-seeded random number sequences
    and breaking tests that rely on specific random numbers being generated.
    To disable the
    usage of `tf.random.Generator`, please use
    `tf.keras.backend.experimental.disable_random_generator`.

    We expect the `tf.random.Generator` code path to become the default, and
    will remove the legacy stateful random ops such as `tf.random.uniform` in
    the future (see the [TF RNG guide](
    https://www.tensorflow.org/guide/random_numbers)).

    This API will also be removed in a future release as well, together with
    `tf.keras.backend.experimental.enable_tf_random_generator()` and
    `tf.keras.backend.experimental.disable_tf_random_generator()`

    Returns:
      boolean: whether `tf.random.Generator` is used for random number
        generation in Keras.
    """
    ...

@keras_export("keras.backend.experimental.enable_tf_random_generator", v1=[])
def enable_tf_random_generator(): # -> None:
    """Enable the `tf.random.Generator` as the RNG for Keras.

    See `tf.keras.backend.experimental.is_tf_random_generator_enabled` for more
    details.
    """
    ...

@keras_export("keras.backend.experimental.disable_tf_random_generator", v1=[])
def disable_tf_random_generator(): # -> None:
    """Disable the `tf.random.Generator` as the RNG for Keras.

    See `tf.keras.backend.experimental.is_tf_random_generator_enabled` for more
    details.
    """
    ...

class RandomGenerator(tf.__internal__.tracking.AutoTrackable):
    """Random generator that selects appropriate random ops.

    This class contains the logic for legacy stateful random ops, as well as the
    new stateless random ops with seeds and tf.random.Generator. Any class that
    relies on RNG (eg initializer, shuffle, dropout) should use this class to
    handle the transition from legacy RNGs to new RNGs.

    Args:
      seed: Optional int seed. When `rng_type` is "stateful", the seed is used
        to create `tf.random.Generator` to produce deterministic sequences.
        When `rng_type` is "stateless", new seed will be created if it is not
        provided by user, and it will be passed down to stateless random ops.
        When `rng_type` is "legacy_stateful", the seed will be passed down to
        stateful random ops.
      rng_type: Type of RNG to use, one of "stateful", "stateless",
        "legacy_stateful". It defaults to "stateful" if
        `enable_tf_random_generator` has been activated, or to
        "legacy_stateful" otherwise.
        - When using "stateless", the random ops outputs are constant (the same
          inputs result in the same outputs).
        - When using "stateful" or "legacy_stateful", the random ops outputs are
          non-constant, but deterministic: calling the same random op multiple
          times with the same inputs results in a deterministic sequence of
          different outputs.
        - "legacy_stateful" is backed by TF1 stateful RNG ops
          (e.g. `tf.random.uniform`), while "stateful"
          is backed by TF2 APIs (e.g. `tf.random.Generator.uniform`).
    """
    RNG_STATELESS = ...
    RNG_STATEFUL = ...
    RNG_LEGACY_STATEFUL = ...
    def __init__(self, seed=..., rng_type=..., **kwargs) -> None:
        ...
    
    def make_seed_for_stateless_op(self): # -> list[Unknown] | None:
        """Generate a new seed based on the init config.

        Note that this will not return python ints which will be frozen in the
        graph and cause stateless op to return the same value. It will only
        return value when generator is used, otherwise it will return None.

        Returns:
          A tensor with shape [2,].
        """
        ...
    
    def make_legacy_seed(self): # -> Any | int | None:
        """Create a new seed for the legacy stateful ops to use.

        When user didn't provide any original seed, this method will return
        None.  Otherwise it will increment the counter and return as the new
        seed.

        Note that it is important to generate different seed for stateful ops in
        the `tf.function`. The random ops will return same value when same seed
        is provided in the `tf.function`.

        Returns:
          int as new seed, or None.
        """
        ...
    
    def random_normal(self, shape, mean=..., stddev=..., dtype=..., nonce=...):
        """Produce random number based on the normal distribution.

        Args:
          shape: The shape of the random values to generate.
          mean: Floats, default to 0. Mean of the random values to generate.
          stddev: Floats, default to 1. Standard deviation of the random values
            to generate.
          dtype: Optional dtype of the tensor. Only floating point types are
            supported. If not specified, `tf.keras.backend.floatx()` is used,
            which default to `float32` unless you configured it otherwise (via
            `tf.keras.backend.set_floatx(float_dtype)`)
          nonce: Optional integer scalar, that will be folded into the seed in
            the stateless mode.
        """
        ...
    
    def random_uniform(self, shape, minval=..., maxval=..., dtype=..., nonce=...):
        """Produce random number based on the uniform distribution.

        Args:
          shape: The shape of the random values to generate.
          minval: Floats, default to 0. Lower bound of the range of
            random values to generate (inclusive).
          minval: Floats, default to None. Upper bound of the range of
            random values to generate (exclusive).
          dtype: Optional dtype of the tensor. Only floating point types are
            supported. If not specified, `tf.keras.backend.floatx()` is used,
            which default to `float32` unless you configured it otherwise (via
            `tf.keras.backend.set_floatx(float_dtype)`)
          nonce: Optional integer scalar, that will be folded into the seed in
            the stateless mode.
        """
        ...
    
    def truncated_normal(self, shape, mean=..., stddev=..., dtype=..., nonce=...):
        """Produce random number based on the truncated normal distribution.

        Args:
          shape: The shape of the random values to generate.
          mean: Floats, default to 0. Mean of the random values to generate.
          stddev: Floats, default to 1. Standard deviation of the random values
            to generate.
          dtype: Optional dtype of the tensor. Only floating point types are
            supported. If not specified, `tf.keras.backend.floatx()` is used,
            which default to `float32` unless you configured it otherwise (via
            `tf.keras.backend.set_floatx(float_dtype)`)
          nonce: Optional integer scalar, that will be folded into the seed in
            the stateless mode.
        """
        ...
    
    def dropout(self, inputs, rate, noise_shape=...):
        ...
    


@keras_export("keras.backend.random_uniform_variable")
@doc_controls.do_not_generate_docs
def random_uniform_variable(shape, low, high, dtype=..., name=..., seed=...):
    """Instantiates a variable with values drawn from a uniform distribution.

    Args:
        shape: Tuple of integers, shape of returned Keras variable.
        low: Float, lower boundary of the output interval.
        high: Float, upper boundary of the output interval.
        dtype: String, dtype of returned Keras variable.
        name: String, name of returned Keras variable.
        seed: Integer, random seed.

    Returns:
        A Keras variable, filled with drawn samples.

    Example:

    >>> kvar = tf.keras.backend.random_uniform_variable(shape=(2,3),
    ... low=0.0, high=1.0)
    >>> kvar
    <tf.Variable 'Variable:0' shape=(2, 3) dtype=float32, numpy=...,
    dtype=float32)>
    """
    ...

@keras_export("keras.backend.random_normal_variable")
@doc_controls.do_not_generate_docs
def random_normal_variable(shape, mean, scale, dtype=..., name=..., seed=...):
    """Instantiates a variable with values drawn from a normal distribution.

    Args:
        shape: Tuple of integers, shape of returned Keras variable.
        mean: Float, mean of the normal distribution.
        scale: Float, standard deviation of the normal distribution.
        dtype: String, dtype of returned Keras variable.
        name: String, name of returned Keras variable.
        seed: Integer, random seed.

    Returns:
        A Keras variable, filled with drawn samples.

    Example:

    >>> kvar = tf.keras.backend.random_normal_variable(shape=(2,3),
    ... mean=0.0, scale=1.0)
    >>> kvar
    <tf.Variable 'Variable:0' shape=(2, 3) dtype=float32, numpy=...,
    dtype=float32)>
    """
    ...

@keras_export("keras.backend.count_params")
@doc_controls.do_not_generate_docs
def count_params(x): # -> Any:
    """Returns the static number of elements in a variable or tensor.

    Args:
        x: Variable or tensor.

    Returns:
        Integer, the number of scalars in `x`.

    Example:

    >>> kvar = tf.keras.backend.zeros((2,3))
    >>> tf.keras.backend.count_params(kvar)
    6
    >>> tf.keras.backend.eval(kvar)
    array([[0.,  0.,  0.],
           [0.,  0.,  0.]], dtype=float32)

    """
    ...

@keras_export("keras.backend.cast")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def cast(x, dtype):
    """Casts a tensor to a different dtype and returns it.

    You can cast a Keras variable but it still returns a Keras tensor.

    Args:
        x: Keras tensor (or variable).
        dtype: String, either (`'float16'`, `'float32'`, or `'float64'`).

    Returns:
        Keras tensor with dtype `dtype`.

    Examples:
        Cast a float32 variable to a float64 tensor

    >>> input = tf.keras.backend.ones(shape=(1,3))
    >>> print(input)
    <tf.Variable 'Variable:0' shape=(1, 3) dtype=float32,
    numpy=array([[1., 1., 1.]], dtype=float32)>
    >>> cast_input = tf.keras.backend.cast(input, dtype='float64')
    >>> print(cast_input)
    tf.Tensor([[1. 1. 1.]], shape=(1, 3), dtype=float64)

    """
    ...

@keras_export("keras.backend.update")
@doc_controls.do_not_generate_docs
def update(x, new_x):
    ...

@keras_export("keras.backend.update_add")
@doc_controls.do_not_generate_docs
def update_add(x, increment):
    """Update the value of `x` by adding `increment`.

    Args:
        x: A Variable.
        increment: A tensor of same shape as `x`.

    Returns:
        The variable `x` updated.
    """
    ...

@keras_export("keras.backend.update_sub")
@doc_controls.do_not_generate_docs
def update_sub(x, decrement):
    """Update the value of `x` by subtracting `decrement`.

    Args:
        x: A Variable.
        decrement: A tensor of same shape as `x`.

    Returns:
        The variable `x` updated.
    """
    ...

@keras_export("keras.backend.moving_average_update")
@doc_controls.do_not_generate_docs
def moving_average_update(x, value, momentum):
    """Compute the exponential moving average of a value.

    The moving average 'x' is updated with 'value' following:

    ```
    x = x * momentum + value * (1 - momentum)
    ```

    For example:

    >>> x = tf.Variable(0.0)
    >>> momentum=0.9
    >>> moving_average_update(x, value = 2.0, momentum=momentum).numpy()
    >>> x.numpy()
    0.2

    The result will be biased towards the initial value of the variable.

    If the variable was initialized to zero, you can divide by
    `1 - momentum ** num_updates` to debias it (Section 3 of
    [Kingma et al., 2015](https://arxiv.org/abs/1412.6980)):

    >>> num_updates = 1.0
    >>> x_zdb = x/(1 - momentum**num_updates)
    >>> x_zdb.numpy()
    2.0

    Args:
        x: A Variable, the moving average.
        value: A tensor with the same shape as `x`, the new value to be
          averaged in.
        momentum: The moving average momentum.

    Returns:
        The updated variable.
    """
    ...

@keras_export("keras.backend.dot")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def dot(x, y):
    """Multiplies 2 tensors (and/or variables) and returns a tensor.

    This operation corresponds to `numpy.dot(a, b, out=None)`.

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A tensor, dot product of `x` and `y`.

    Examples:

    If inputs `x` and `y` are 2-D arrays, then it is equivalent to `tf.matmul`.
    >>> x = tf.keras.backend.placeholder(shape=(2, 3))
    >>> y = tf.keras.backend.placeholder(shape=(3, 4))
    >>> xy = tf.keras.backend.dot(x, y)
    >>> xy
    <KerasTensor: shape=(2, 4) dtype=float32 ...>

    >>> x = tf.keras.backend.placeholder(shape=(32, 28, 3))
    >>> y = tf.keras.backend.placeholder(shape=(3, 4))
    >>> xy = tf.keras.backend.dot(x, y)
    >>> xy
    <KerasTensor: shape=(32, 28, 4) dtype=float32 ...>

    If `x` is an N-D array and `y` is an M-D array (where M>=2), it is a sum
    product over the last axis of `x` and the second-to-last axis of `y`.
    >>> x = tf.keras.backend.random_uniform_variable(
    ... shape=(2, 3), low=0., high=1.)
    >>> y = tf.keras.backend.ones((4, 3, 5))
    >>> xy = tf.keras.backend.dot(x, y)
    >>> tf.keras.backend.int_shape(xy)
    (2, 4, 5)
    """
    ...

@keras_export("keras.backend.batch_dot")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def batch_dot(x, y, axes=...):
    """Batchwise dot product.

    `batch_dot` is used to compute dot product of `x` and `y` when
    `x` and `y` are data in batch, i.e. in a shape of
    `(batch_size, :)`.
    `batch_dot` results in a tensor or variable with less dimensions
    than the input. If the number of dimensions is reduced to 1,
    we use `expand_dims` to make sure that ndim is at least 2.

    Args:
      x: Keras tensor or variable with `ndim >= 2`.
      y: Keras tensor or variable with `ndim >= 2`.
      axes: Tuple or list of integers with target dimensions, or single integer.
        The sizes of `x.shape[axes[0]]` and `y.shape[axes[1]]` should be equal.

    Returns:
      A tensor with shape equal to the concatenation of `x`'s shape
      (less the dimension that was summed over) and `y`'s shape
      (less the batch dimension and the dimension that was summed over).
      If the final rank is 1, we reshape it to `(batch_size, 1)`.

    Examples:

    >>> x_batch = tf.keras.backend.ones(shape=(32, 20, 1))
    >>> y_batch = tf.keras.backend.ones(shape=(32, 30, 20))
    >>> xy_batch_dot = tf.keras.backend.batch_dot(x_batch, y_batch, axes=(1, 2))
    >>> tf.keras.backend.int_shape(xy_batch_dot)
    (32, 1, 30)

    Shape inference:
      Let `x`'s shape be `(100, 20)` and `y`'s shape be `(100, 30, 20)`.
      If `axes` is (1, 2), to find the output shape of resultant tensor,
          loop through each dimension in `x`'s shape and `y`'s shape:
      * `x.shape[0]` : 100 : append to output shape
      * `x.shape[1]` : 20 : do not append to output shape,
          dimension 1 of `x` has been summed over. (`dot_axes[0]` = 1)
      * `y.shape[0]` : 100 : do not append to output shape,
          always ignore first dimension of `y`
      * `y.shape[1]` : 30 : append to output shape
      * `y.shape[2]` : 20 : do not append to output shape,
          dimension 2 of `y` has been summed over. (`dot_axes[1]` = 2)
      `output_shape` = `(100, 30)`
    """
    ...

@keras_export("keras.backend.transpose")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def transpose(x):
    """Transposes a tensor and returns it.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.

    Examples:

    >>> var = tf.keras.backend.variable([[1, 2, 3], [4, 5, 6]])
    >>> tf.keras.backend.eval(var)
    array([[1.,  2.,  3.],
           [4.,  5.,  6.]], dtype=float32)
    >>> var_transposed = tf.keras.backend.transpose(var)
    >>> tf.keras.backend.eval(var_transposed)
    array([[1.,  4.],
           [2.,  5.],
           [3.,  6.]], dtype=float32)
    >>> input = tf.keras.backend.placeholder((2, 3))
    >>> input
    <KerasTensor: shape=(2, 3) dtype=float32 ...>
    >>> input_transposed = tf.keras.backend.transpose(input)
    >>> input_transposed
    <KerasTensor: shape=(3, 2) dtype=float32 ...>
    """
    ...

@keras_export("keras.backend.gather")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def gather(reference, indices):
    """Retrieves the elements of indices `indices` in the tensor `reference`.

    Args:
        reference: A tensor.
        indices: An integer tensor of indices.

    Returns:
        A tensor of same type as `reference`.

    Examples:

    >>> var = tf.keras.backend.variable([[1, 2, 3], [4, 5, 6]])
    >>> tf.keras.backend.eval(var)
    array([[1., 2., 3.],
           [4., 5., 6.]], dtype=float32)
    >>> var_gathered = tf.keras.backend.gather(var, [0])
    >>> tf.keras.backend.eval(var_gathered)
    array([[1., 2., 3.]], dtype=float32)
    >>> var_gathered = tf.keras.backend.gather(var, [1])
    >>> tf.keras.backend.eval(var_gathered)
    array([[4., 5., 6.]], dtype=float32)
    >>> var_gathered = tf.keras.backend.gather(var, [0,1,0])
    >>> tf.keras.backend.eval(var_gathered)
    array([[1., 2., 3.],
           [4., 5., 6.],
           [1., 2., 3.]], dtype=float32)
    """
    ...

@keras_export("keras.backend.max")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def max(x, axis=..., keepdims=...):
    """Maximum value in a tensor.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to find maximum values.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1. If `keepdims` is `True`,
            the reduced dimension is retained with length 1.

    Returns:
        A tensor with maximum values of `x`.
    """
    ...

@keras_export("keras.backend.min")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def min(x, axis=..., keepdims=...):
    """Minimum value in a tensor.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to find minimum values.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1. If `keepdims` is `True`,
            the reduced dimension is retained with length 1.

    Returns:
        A tensor with minimum values of `x`.
    """
    ...

@keras_export("keras.backend.sum")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def sum(x, axis=..., keepdims=...):
    """Sum of the values in a tensor, alongside the specified axis.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to sum over.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1. If `keepdims` is `True`,
            the reduced dimension is retained with length 1.

    Returns:
        A tensor with sum of `x`.
    """
    ...

@keras_export("keras.backend.prod")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def prod(x, axis=..., keepdims=...):
    """Multiplies the values in a tensor, alongside the specified axis.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to compute the product.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1. If `keepdims` is `True`,
            the reduced dimension is retained with length 1.

    Returns:
        A tensor with the product of elements of `x`.
    """
    ...

@keras_export("keras.backend.cumsum")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def cumsum(x, axis=...):
    """Cumulative sum of the values in a tensor, alongside the specified axis.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to compute the sum.

    Returns:
        A tensor of the cumulative sum of values of `x` along `axis`.
    """
    ...

@keras_export("keras.backend.cumprod")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def cumprod(x, axis=...):
    """Cumulative product of the values in a tensor, alongside the specified axis.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to compute the product.

    Returns:
        A tensor of the cumulative product of values of `x` along `axis`.
    """
    ...

@keras_export("keras.backend.var")
@doc_controls.do_not_generate_docs
def var(x, axis=..., keepdims=...):
    """Variance of a tensor, alongside the specified axis.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to compute the variance.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1. If `keepdims` is `True`,
            the reduced dimension is retained with length 1.

    Returns:
        A tensor with the variance of elements of `x`.
    """
    ...

@keras_export("keras.backend.std")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def std(x, axis=..., keepdims=...):
    """Standard deviation of a tensor, alongside the specified axis.

    It is an alias to `tf.math.reduce_std`.

    Args:
        x: A tensor or variable. It should have numerical dtypes. Boolean type
          inputs will be converted to float.
        axis: An integer, the axis to compute the standard deviation. If `None`
          (the default), reduces all dimensions. Must be in the range
          `[-rank(x), rank(x))`.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1. If `keepdims` is `True`, the reduced dimension is retained
            with length 1.

    Returns:
        A tensor with the standard deviation of elements of `x` with same dtype.
        Boolean type input will be converted to float.
    """
    ...

@keras_export("keras.backend.mean")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def mean(x, axis=..., keepdims=...):
    """Mean of a tensor, alongside the specified axis.

    Args:
        x: A tensor or variable.
        axis: A list of integer. Axes to compute the mean.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1 for each entry in `axis`. If `keepdims` is `True`,
            the reduced dimensions are retained with length 1.

    Returns:
        A tensor with the mean of elements of `x`.
    """
    ...

@keras_export("keras.backend.any")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def any(x, axis=..., keepdims=...):
    """Bitwise reduction (logical OR).

    Args:
        x: Tensor or variable.
        axis: axis along which to perform the reduction.
        keepdims: whether the drop or broadcast the reduction axes.

    Returns:
        A uint8 tensor (0s and 1s).
    """
    ...

@keras_export("keras.backend.all")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def all(x, axis=..., keepdims=...):
    """Bitwise reduction (logical AND).

    Args:
        x: Tensor or variable.
        axis: axis along which to perform the reduction.
        keepdims: whether the drop or broadcast the reduction axes.

    Returns:
        A uint8 tensor (0s and 1s).
    """
    ...

@keras_export("keras.backend.argmax")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def argmax(x, axis=...):
    """Returns the index of the maximum value along an axis.

    Args:
        x: Tensor or variable.
        axis: axis along which to perform the reduction.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.argmin")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def argmin(x, axis=...):
    """Returns the index of the minimum value along an axis.

    Args:
        x: Tensor or variable.
        axis: axis along which to perform the reduction.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.square")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def square(x):
    """Element-wise square.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.abs")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def abs(x):
    """Element-wise absolute value.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.sqrt")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def sqrt(x):
    """Element-wise square root.

       This function clips negative tensor values to 0 before computing the
       square root.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.exp")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def exp(x):
    """Element-wise exponential.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.log")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def log(x):
    """Element-wise log.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

def logsumexp(x, axis=..., keepdims=...):
    """Computes log(sum(exp(elements across dimensions of a tensor))).

    This function is more numerically stable than log(sum(exp(x))).
    It avoids overflows caused by taking the exp of large inputs and
    underflows caused by taking the log of small inputs.

    Args:
        x: A tensor or variable.
        axis: An integer, the axis to reduce over.
        keepdims: A boolean, whether to keep the dimensions or not.
            If `keepdims` is `False`, the rank of the tensor is reduced
            by 1. If `keepdims` is `True`, the reduced dimension is
            retained with length 1.

    Returns:
        The reduced tensor.
    """
    ...

@keras_export("keras.backend.round")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def round(x):
    """Element-wise rounding to the closest integer.

    In case of tie, the rounding mode used is "half to even".

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.sign")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def sign(x):
    """Element-wise sign.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.pow")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def pow(x, a):
    """Element-wise exponentiation.

    Args:
        x: Tensor or variable.
        a: Python integer.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.clip")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def clip(x, min_value, max_value):
    """Element-wise value clipping.

    Args:
        x: Tensor or variable.
        min_value: Python float, integer, or tensor.
        max_value: Python float, integer, or tensor.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.equal")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def equal(x, y):
    """Element-wise equality between two tensors.

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A bool tensor.
    """
    ...

@keras_export("keras.backend.not_equal")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def not_equal(x, y):
    """Element-wise inequality between two tensors.

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A bool tensor.
    """
    ...

@keras_export("keras.backend.greater")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def greater(x, y):
    """Element-wise truth value of (x > y).

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A bool tensor.
    """
    ...

@keras_export("keras.backend.greater_equal")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def greater_equal(x, y):
    """Element-wise truth value of (x >= y).

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A bool tensor.
    """
    ...

@keras_export("keras.backend.less")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def less(x, y):
    """Element-wise truth value of (x < y).

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A bool tensor.
    """
    ...

@keras_export("keras.backend.less_equal")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def less_equal(x, y):
    """Element-wise truth value of (x <= y).

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A bool tensor.
    """
    ...

@keras_export("keras.backend.maximum")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def maximum(x, y):
    """Element-wise maximum of two tensors.

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A tensor with the element wise maximum value(s) of `x` and `y`.

    Examples:

    >>> x = tf.Variable([[1, 2], [3, 4]])
    >>> y = tf.Variable([[2, 1], [0, -1]])
    >>> m = tf.keras.backend.maximum(x, y)
    >>> m
    <tf.Tensor: shape=(2, 2), dtype=int32, numpy=
    array([[2, 2],
           [3, 4]], dtype=int32)>
    """
    ...

@keras_export("keras.backend.minimum")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def minimum(x, y):
    """Element-wise minimum of two tensors.

    Args:
        x: Tensor or variable.
        y: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.sin")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def sin(x):
    """Computes sin of x element-wise.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.cos")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def cos(x):
    """Computes cos of x element-wise.

    Args:
        x: Tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.normalize_batch_in_training")
@doc_controls.do_not_generate_docs
def normalize_batch_in_training(x, gamma, beta, reduction_axes, epsilon=...): # -> tuple[Unknown, Unknown, Unknown]:
    """Computes mean and std for batch then apply batch_normalization on batch.

    Args:
        x: Input tensor or variable.
        gamma: Tensor by which to scale the input.
        beta: Tensor with which to center the input.
        reduction_axes: iterable of integers,
            axes over which to normalize.
        epsilon: Fuzz factor.

    Returns:
        A tuple length of 3, `(normalized_tensor, mean, variance)`.
    """
    ...

@keras_export("keras.backend.batch_normalization")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def batch_normalization(x, mean, var, beta, gamma, axis=..., epsilon=...):
    """Applies batch normalization on x given mean, var, beta and gamma.

    I.e. returns:
    `output = (x - mean) / (sqrt(var) + epsilon) * gamma + beta`

    Args:
        x: Input tensor or variable.
        mean: Mean of batch.
        var: Variance of batch.
        beta: Tensor with which to center the input.
        gamma: Tensor by which to scale the input.
        axis: Integer, the axis that should be normalized.
            (typically the features axis).
        epsilon: Fuzz factor.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.concatenate")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def concatenate(tensors, axis=...):
    """Concatenates a list of tensors alongside the specified axis.

    Args:
        tensors: list of tensors to concatenate.
        axis: concatenation axis.

    Returns:
        A tensor.

    Example:

        >>> a = tf.constant([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        >>> b = tf.constant([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
        >>> tf.keras.backend.concatenate((a, b), axis=-1)
        <tf.Tensor: shape=(3, 6), dtype=int32, numpy=
        array([[ 1,  2,  3, 10, 20, 30],
               [ 4,  5,  6, 40, 50, 60],
               [ 7,  8,  9, 70, 80, 90]], dtype=int32)>

    """
    ...

@keras_export("keras.backend.reshape")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def reshape(x, shape):
    """Reshapes a tensor to the specified shape.

    Args:
        x: Tensor or variable.
        shape: Target shape tuple.

    Returns:
        A tensor.

    Example:

      >>> a = tf.constant([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
      >>> a
      <tf.Tensor: shape=(4, 3), dtype=int32, numpy=
      array([[ 1,  2,  3],
             [ 4,  5,  6],
             [ 7,  8,  9],
             [10, 11, 12]], dtype=int32)>
      >>> tf.keras.backend.reshape(a, shape=(2, 6))
      <tf.Tensor: shape=(2, 6), dtype=int32, numpy=
      array([[ 1,  2,  3,  4,  5,  6],
             [ 7,  8,  9, 10, 11, 12]], dtype=int32)>

    """
    ...

@keras_export("keras.backend.permute_dimensions")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def permute_dimensions(x, pattern):
    """Permutes axes in a tensor.

    Args:
        x: Tensor or variable.
        pattern: A tuple of
            dimension indices, e.g. `(0, 2, 1)`.

    Returns:
        A tensor.

    Example:

      >>> a = tf.constant([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
      >>> a
      <tf.Tensor: shape=(4, 3), dtype=int32, numpy=
      array([[ 1,  2,  3],
             [ 4,  5,  6],
             [ 7,  8,  9],
             [10, 11, 12]], dtype=int32)>
      >>> tf.keras.backend.permute_dimensions(a, pattern=(1, 0))
      <tf.Tensor: shape=(3, 4), dtype=int32, numpy=
      array([[ 1,  4,  7, 10],
             [ 2,  5,  8, 11],
             [ 3,  6,  9, 12]], dtype=int32)>

    """
    ...

@keras_export("keras.backend.resize_images")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def resize_images(x, height_factor, width_factor, data_format, interpolation=...):
    """Resizes the images contained in a 4D tensor.

    Args:
        x: Tensor or variable to resize.
        height_factor: Positive integer.
        width_factor: Positive integer.
        data_format: One of `"channels_first"`, `"channels_last"`.
        interpolation: A string, one of `"area"`, `"bicubic"`, `"bilinear"`,
          `"gaussian"`, `"lanczos3"`, `"lanczos5"`, `"mitchellcubic"`,
          `"nearest"`.

    Returns:
        A tensor.

    Raises:
        ValueError: in case of incorrect value for
          `data_format` or `interpolation`.
    """
    ...

@keras_export("keras.backend.resize_volumes")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def resize_volumes(x, depth_factor, height_factor, width_factor, data_format):
    """Resizes the volume contained in a 5D tensor.

    Args:
        x: Tensor or variable to resize.
        depth_factor: Positive integer.
        height_factor: Positive integer.
        width_factor: Positive integer.
        data_format: One of `"channels_first"`, `"channels_last"`.

    Returns:
        A tensor.

    Raises:
        ValueError: if `data_format` is neither
            `channels_last` or `channels_first`.
    """
    ...

@keras_export("keras.backend.repeat_elements")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def repeat_elements(x, rep, axis):
    """Repeats the elements of a tensor along an axis, like `np.repeat`.

    If `x` has shape `(s1, s2, s3)` and `axis` is `1`, the output
    will have shape `(s1, s2 * rep, s3)`.

    Args:
        x: Tensor or variable.
        rep: Python integer, number of times to repeat.
        axis: Axis along which to repeat.

    Returns:
        A tensor.

    Example:

        >>> b = tf.constant([1, 2, 3])
        >>> tf.keras.backend.repeat_elements(b, rep=2, axis=0)
        <tf.Tensor: shape=(6,), dtype=int32,
            numpy=array([1, 1, 2, 2, 3, 3], dtype=int32)>

    """
    ...

@keras_export("keras.backend.repeat")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def repeat(x, n):
    """Repeats a 2D tensor.

    if `x` has shape (samples, dim) and `n` is `2`,
    the output will have shape `(samples, 2, dim)`.

    Args:
        x: Tensor or variable.
        n: Python integer, number of times to repeat.

    Returns:
        A tensor.

    Example:

        >>> b = tf.constant([[1, 2], [3, 4]])
        >>> b
        <tf.Tensor: shape=(2, 2), dtype=int32, numpy=
        array([[1, 2],
               [3, 4]], dtype=int32)>
        >>> tf.keras.backend.repeat(b, n=2)
        <tf.Tensor: shape=(2, 2, 2), dtype=int32, numpy=
        array([[[1, 2],
                [1, 2]],
               [[3, 4],
                [3, 4]]], dtype=int32)>

    """
    ...

@keras_export("keras.backend.arange")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def arange(start, stop=..., step=..., dtype=...):
    """Creates a 1D tensor containing a sequence of integers.

    The function arguments use the same convention as
    Theano's arange: if only one argument is provided,
    it is in fact the "stop" argument and "start" is 0.

    The default type of the returned tensor is `'int32'` to
    match TensorFlow's default.

    Args:
        start: Start value.
        stop: Stop value.
        step: Difference between two successive values.
        dtype: Integer dtype to use.

    Returns:
        An integer tensor.

    Example:

        >>> tf.keras.backend.arange(start=0, stop=10, step=1.5)
        <tf.Tensor: shape=(7,), dtype=float32,
            numpy=array([0. , 1.5, 3. , 4.5, 6. , 7.5, 9. ], dtype=float32)>



    """
    ...

@keras_export("keras.backend.tile")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def tile(x, n):
    """Creates a tensor by tiling `x` by `n`.

    Args:
        x: A tensor or variable
        n: A list of integer. The length must be the same as the number of
            dimensions in `x`.

    Returns:
        A tiled tensor.
    """
    ...

@keras_export("keras.backend.flatten")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def flatten(x):
    """Flatten a tensor.

    Args:
        x: A tensor or variable.

    Returns:
        A tensor, reshaped into 1-D

    Example:

        >>> b = tf.constant([[1, 2], [3, 4]])
        >>> b
        <tf.Tensor: shape=(2, 2), dtype=int32, numpy=
        array([[1, 2],
               [3, 4]], dtype=int32)>
        >>> tf.keras.backend.flatten(b)
        <tf.Tensor: shape=(4,), dtype=int32,
            numpy=array([1, 2, 3, 4], dtype=int32)>

    """
    ...

@keras_export("keras.backend.batch_flatten")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def batch_flatten(x):
    """Turn a nD tensor into a 2D tensor with same 0th dimension.

    In other words, it flattens each data samples of a batch.

    Args:
        x: A tensor or variable.

    Returns:
        A tensor.

    Examples:
      Flattening a 3D tensor to 2D by collapsing the last dimension.

    >>> x_batch = tf.keras.backend.ones(shape=(2, 3, 4, 5))
    >>> x_batch_flatten = batch_flatten(x_batch)
    >>> tf.keras.backend.int_shape(x_batch_flatten)
    (2, 60)

    """
    ...

@keras_export("keras.backend.expand_dims")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def expand_dims(x, axis=...):
    """Adds a 1-sized dimension at index "axis".

    Args:
        x: A tensor or variable.
        axis: Position where to add a new axis.

    Returns:
        A tensor with expanded dimensions.
    """
    ...

@keras_export("keras.backend.squeeze")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def squeeze(x, axis):
    """Removes a 1-dimension from the tensor at index "axis".

    Args:
        x: A tensor or variable.
        axis: Axis to drop.

    Returns:
        A tensor with the same data as `x` but reduced dimensions.
    """
    ...

@keras_export("keras.backend.temporal_padding")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def temporal_padding(x, padding=...):
    """Pads the middle dimension of a 3D tensor.

    Args:
        x: Tensor or variable.
        padding: Tuple of 2 integers, how many zeros to
            add at the start and end of dim 1.

    Returns:
        A padded 3D tensor.
    """
    ...

@keras_export("keras.backend.spatial_2d_padding")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def spatial_2d_padding(x, padding=..., data_format=...):
    """Pads the 2nd and 3rd dimensions of a 4D tensor.

    Args:
        x: Tensor or variable.
        padding: Tuple of 2 tuples, padding pattern.
        data_format: One of `channels_last` or `channels_first`.

    Returns:
        A padded 4D tensor.

    Raises:
        ValueError: if `data_format` is neither
            `channels_last` or `channels_first`.
    """
    ...

@keras_export("keras.backend.spatial_3d_padding")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def spatial_3d_padding(x, padding=..., data_format=...):
    """Pads 5D tensor with zeros along the depth, height, width dimensions.

    Pads these dimensions with respectively
    "padding[0]", "padding[1]" and "padding[2]" zeros left and right.

    For 'channels_last' data_format,
    the 2nd, 3rd and 4th dimension will be padded.
    For 'channels_first' data_format,
    the 3rd, 4th and 5th dimension will be padded.

    Args:
        x: Tensor or variable.
        padding: Tuple of 3 tuples, padding pattern.
        data_format: One of `channels_last` or `channels_first`.

    Returns:
        A padded 5D tensor.

    Raises:
        ValueError: if `data_format` is neither
            `channels_last` or `channels_first`.

    """
    ...

@keras_export("keras.backend.stack")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def stack(x, axis=...):
    """Stacks a list of rank `R` tensors into a rank `R+1` tensor.

    Args:
        x: List of tensors.
        axis: Axis along which to perform stacking.

    Returns:
        A tensor.

    Example:

        >>> a = tf.constant([[1, 2],[3, 4]])
        >>> b = tf.constant([[10, 20],[30, 40]])
        >>> tf.keras.backend.stack((a, b))
        <tf.Tensor: shape=(2, 2, 2), dtype=int32, numpy=
        array([[[ 1,  2],
                [ 3,  4]],
               [[10, 20],
                [30, 40]]], dtype=int32)>

    """
    ...

@keras_export("keras.backend.one_hot")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def one_hot(indices, num_classes):
    """Computes the one-hot representation of an integer tensor.

    Args:
        indices: nD integer tensor of shape
            `(batch_size, dim1, dim2, ... dim(n-1))`
        num_classes: Integer, number of classes to consider.

    Returns:
        (n + 1)D one hot representation of the input
        with shape `(batch_size, dim1, dim2, ... dim(n-1), num_classes)`

    Returns:
        The one-hot tensor.
    """
    ...

@keras_export("keras.backend.reverse")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def reverse(x, axes):
    """Reverse a tensor along the specified axes.

    Args:
        x: Tensor to reverse.
        axes: Integer or iterable of integers.
            Axes to reverse.

    Returns:
        A tensor.
    """
    ...

_VALUE_SET_CODE_STRING = ...
@keras_export("keras.backend.get_value")
@doc_controls.do_not_generate_docs
def get_value(x):
    """Returns the value of a variable.

    `backend.get_value` is the complement of `backend.set_value`, and provides
    a generic interface for reading from variables while abstracting away the
    differences between TensorFlow 1.x and 2.x semantics.

    {snippet}

    Args:
        x: input variable.

    Returns:
        A Numpy array.
    """
    ...

@keras_export("keras.backend.batch_get_value")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def batch_get_value(tensors): # -> list[Unknown]:
    """Returns the value of more than one tensor variable.

    Args:
        tensors: list of ops to run.

    Returns:
        A list of Numpy arrays.

    Raises:
        RuntimeError: If this method is called inside defun.
    """
    ...

@keras_export("keras.backend.set_value")
@doc_controls.do_not_generate_docs
def set_value(x, value): # -> None:
    """Sets the value of a variable, from a Numpy array.

    `backend.set_value` is the complement of `backend.get_value`, and provides
    a generic interface for assigning to variables while abstracting away the
    differences between TensorFlow 1.x and 2.x semantics.

    {snippet}

    Args:
        x: Variable to set to a new value.
        value: Value to set the tensor to, as a Numpy array
            (of the same shape).
    """
    ...

@keras_export("keras.backend.batch_set_value")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def batch_set_value(tuples): # -> None:
    """Sets the values of many tensor variables at once.

    Args:
        tuples: a list of tuples `(tensor, value)`.
            `value` should be a Numpy array.
    """
    ...

@keras_export("keras.backend.print_tensor")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def print_tensor(x, message=..., summarize=...):
    """Prints `message` and the tensor value when evaluated.

    Note that `print_tensor` returns a new tensor identical to `x`
    which should be used in the following code. Otherwise the
    print operation is not taken into account during evaluation.

    Example:

    >>> x = tf.constant([[1.0, 2.0], [3.0, 4.0]])
    >>> tf.keras.backend.print_tensor(x)
    <tf.Tensor: shape=(2, 2), dtype=float32, numpy=
      array([[1., 2.],
             [3., 4.]], dtype=float32)>

    Args:
        x: Tensor to print.
        message: Message to print jointly with the tensor.
        summarize: The first and last `summarize` elements within each dimension
            are recursively printed per Tensor. If None, then the first 3 and
            last 3 elements of each dimension are printed for each tensor. If
            set to -1, it will print all elements of every tensor.

    Returns:
        The same tensor `x`, unchanged.
    """
    ...

class GraphExecutionFunction:
    """Runs a computation graph.

    It's possible to pass arguments to `tf.Session.run()` via `session_kwargs`.
    In particular additional operations via `fetches` argument and additional
    tensor substitutions via `feed_dict` arguments. Note that given
    substitutions are merged with substitutions from `inputs`. Even though
    `feed_dict` is passed once in the constructor (called in `model.compile()`)
    we can modify the values in the dictionary. Through this feed_dict we can
    provide additional substitutions besides Keras inputs.

    Args:
        inputs: Feed placeholders to the computation graph.
        outputs: Output tensors to fetch.
        updates: Additional update ops to be run at function call.
        name: A name to help users identify what this function does.
        session_kwargs: Arguments to `tf.Session.run()`:
                        `fetches`, `feed_dict`, `options`, `run_metadata`.
    """
    def __init__(self, inputs, outputs, updates=..., name=..., **session_kwargs) -> None:
        ...
    
    def __call__(self, inputs):
        ...
    


@keras_export("keras.backend.function")
@doc_controls.do_not_generate_docs
def function(inputs, outputs, updates=..., name=..., **kwargs): # -> ((model_inputs: Unknown) -> Unknown) | GraphExecutionFunction:
    """Instantiates a Keras function.

    Args:
        inputs: List of placeholder tensors.
        outputs: List of output tensors.
        updates: List of update ops.
        name: String, name of function.
        **kwargs: Passed to `tf.Session.run`.

    Returns:
        Output values as Numpy arrays.

    Raises:
        ValueError: if invalid kwargs are passed in or if in eager execution.
    """
    ...

@keras_export("keras.backend.gradients")
@doc_controls.do_not_generate_docs
def gradients(loss, variables):
    """Returns the gradients of `loss` w.r.t. `variables`.

    Args:
        loss: Scalar tensor to minimize.
        variables: List of variables.

    Returns:
        A gradients tensor.
    """
    ...

@keras_export("keras.backend.stop_gradient")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def stop_gradient(variables): # -> map[Unknown]:
    """Returns `variables` but with zero gradient w.r.t. every other variable.

    Args:
        variables: Tensor or list of tensors to consider constant with respect
          to any other variable.


    Returns:
        A single tensor or a list of tensors (depending on the passed argument)
        that has no gradient with respect to any other variable.
    """
    ...

@keras_export("keras.backend.rnn")
@tf.__internal__.dispatch.add_dispatch_support
def rnn(step_function, inputs, initial_states, go_backwards=..., mask=..., constants=..., unroll=..., input_length=..., time_major=..., zero_output_for_mask=..., return_all_outputs=...):
    """Iterates over the time dimension of a tensor.

    Args:
        step_function: RNN step function.
            Args;
                input; Tensor with shape `(samples, ...)` (no time dimension),
                    representing input for the batch of samples at a certain
                    time step.
                states; List of tensors.
            Returns;
                output; Tensor with shape `(samples, output_dim)`
                    (no time dimension).
                new_states; List of tensors, same length and shapes
                    as 'states'. The first state in the list must be the
                    output tensor at the previous timestep.
        inputs: Tensor of temporal data of shape `(samples, time, ...)`
            (at least 3D), or nested tensors, and each of which has shape
            `(samples, time, ...)`.
        initial_states: Tensor with shape `(samples, state_size)`
            (no time dimension), containing the initial values for the states
            used in the step function. In the case that state_size is in a
            nested shape, the shape of initial_states will also follow the
            nested structure.
        go_backwards: Boolean. If True, do the iteration over the time
            dimension in reverse order and return the reversed sequence.
        mask: Binary tensor with shape `(samples, time, 1)`,
            with a zero for every element that is masked.
        constants: List of constant values passed at each step.
        unroll: Whether to unroll the RNN or to use a symbolic `while_loop`.
        input_length: An integer or a 1-D Tensor, depending on whether
            the time dimension is fixed-length or not. In case of variable
            length input, it is used for masking in case there's no mask
            specified.
        time_major: Boolean. If true, the inputs and outputs will be in shape
            `(timesteps, batch, ...)`, whereas in the False case, it will be
            `(batch, timesteps, ...)`. Using `time_major = True` is a bit more
            efficient because it avoids transposes at the beginning and end of
            the RNN calculation. However, most TensorFlow data is batch-major,
            so by default this function accepts input and emits output in
            batch-major form.
        zero_output_for_mask: Boolean. If True, the output for masked timestep
            will be zeros, whereas in the False case, output from previous
            timestep is returned.
        return_all_outputs: Boolean. If True, return the recurrent outputs for
            all timesteps in the sequence. If False, only return the output for
            the last timestep (which consumes less memory).

    Returns:
        A tuple, `(last_output, outputs, new_states)`.
            last_output: the latest output of the rnn, of shape `(samples, ...)`
            outputs:
                - If `return_all_outputs=True`: a tensor with shape
                  `(samples, time, ...)` where each entry `outputs[s, t]` is the
                  output of the step function at time `t` for sample `s`
                - Else, a tensor equal to `last_output` with shape
                  `(samples, 1, ...)`
            new_states: list of tensors, latest states returned by
                the step function, of shape `(samples, ...)`.

    Raises:
        ValueError: if input dimension is less than 3.
        ValueError: if `unroll` is `True` but input timestep is not a fixed
            number.
        ValueError: if `mask` is provided (not `None`) but states is not
            provided (`len(states)` == 0).
    """
    ...

@keras_export("keras.backend.switch")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def switch(condition, then_expression, else_expression):
    """Switches between two operations depending on a scalar value.

    Note that both `then_expression` and `else_expression`
    should be symbolic tensors of the *same shape*.

    Args:
        condition: tensor (`int` or `bool`).
        then_expression: either a tensor, or a callable that returns a tensor.
        else_expression: either a tensor, or a callable that returns a tensor.

    Returns:
        The selected tensor.

    Raises:
        ValueError: If rank of `condition` is greater than rank of expressions.
    """
    ...

@keras_export("keras.backend.in_train_phase")
@doc_controls.do_not_generate_docs
def in_train_phase(x, alt, training=...):
    """Selects `x` in train phase, and `alt` otherwise.

    Note that `alt` should have the *same shape* as `x`.

    Args:
        x: What to return in train phase
            (tensor or callable that returns a tensor).
        alt: What to return otherwise
            (tensor or callable that returns a tensor).
        training: Optional scalar tensor
            (or Python boolean, or Python integer)
            specifying the learning phase.

    Returns:
        Either `x` or `alt` based on the `training` flag.
        the `training` flag defaults to `K.learning_phase()`.
    """
    ...

@keras_export("keras.backend.in_test_phase")
@doc_controls.do_not_generate_docs
def in_test_phase(x, alt, training=...):
    """Selects `x` in test phase, and `alt` otherwise.

    Note that `alt` should have the *same shape* as `x`.

    Args:
        x: What to return in test phase
            (tensor or callable that returns a tensor).
        alt: What to return otherwise
            (tensor or callable that returns a tensor).
        training: Optional scalar tensor
            (or Python boolean, or Python integer)
            specifying the learning phase.

    Returns:
        Either `x` or `alt` based on `K.learning_phase`.
    """
    ...

@keras_export("keras.backend.relu")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def relu(x, alpha=..., max_value=..., threshold=...):
    """Rectified linear unit.

    With default values, it returns element-wise `max(x, 0)`.

    Otherwise, it follows:
    `f(x) = max_value` for `x >= max_value`,
    `f(x) = x` for `threshold <= x < max_value`,
    `f(x) = alpha * (x - threshold)` otherwise.

    Args:
        x: A tensor or variable.
        alpha: A scalar, slope of negative section (default=`0.`).
        max_value: float. Saturation threshold.
        threshold: float. Threshold value for thresholded activation.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.elu")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def elu(x, alpha=...):
    """Exponential linear unit.

    Args:
        x: A tensor or variable to compute the activation function for.
        alpha: A scalar, slope of negative section.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.softmax")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def softmax(x, axis=...):
    """Softmax of a tensor.

    Args:
        x: A tensor or variable.
        axis: The dimension softmax would be performed on.
            The default is -1 which indicates the last dimension.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.softplus")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def softplus(x):
    """Softplus of a tensor.

    Args:
        x: A tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.softsign")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def softsign(x):
    """Softsign of a tensor.

    Args:
        x: A tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.categorical_crossentropy")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def categorical_crossentropy(target, output, from_logits=..., axis=...):
    """Categorical crossentropy between an output tensor and a target tensor.

    Args:
        target: A tensor of the same shape as `output`.
        output: A tensor resulting from a softmax
            (unless `from_logits` is True, in which
            case `output` is expected to be the logits).
        from_logits: Boolean, whether `output` is the
            result of a softmax, or is a tensor of logits.
        axis: Int specifying the channels axis. `axis=-1` corresponds to data
            format `channels_last`, and `axis=1` corresponds to data format
            `channels_first`.

    Returns:
        Output tensor.

    Raises:
        ValueError: if `axis` is neither -1 nor one of the axes of `output`.

    Example:

    >>> a = tf.constant([1., 0., 0., 0., 1., 0., 0., 0., 1.], shape=[3,3])
    >>> print(a)
    tf.Tensor(
      [[1. 0. 0.]
       [0. 1. 0.]
       [0. 0. 1.]], shape=(3, 3), dtype=float32)
    >>> b = tf.constant([.9, .05, .05, .05, .89, .06, .05, .01, .94],
    ...                 shape=[3, 3])
    >>> print(b)
    tf.Tensor(
      [[0.9  0.05 0.05]
       [0.05 0.89 0.06]
       [0.05 0.01 0.94]], shape=(3, 3), dtype=float32)
    >>> loss = tf.keras.backend.categorical_crossentropy(a, b)
    >>> print(np.around(loss, 5))
    [0.10536 0.11653 0.06188]
    >>> loss = tf.keras.backend.categorical_crossentropy(a, a)
    >>> print(np.around(loss, 5))
    [0. 0. 0.]

    """
    ...

@keras_export("keras.backend.sparse_categorical_crossentropy")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def sparse_categorical_crossentropy(target, output, from_logits=..., axis=..., ignore_class=...):
    """Categorical crossentropy with integer targets.

    Args:
        target: An integer tensor.
        output: A tensor resulting from a softmax
            (unless `from_logits` is True, in which
            case `output` is expected to be the logits).
        from_logits: Boolean, whether `output` is the
            result of a softmax, or is a tensor of logits.
        axis: Int specifying the channels axis. `axis=-1` corresponds to data
            format `channels_last`, and `axis=1` corresponds to data format
            `channels_first`.
        ignore_class: Optional integer. The ID of a class to be ignored
            during loss computation. This is useful, for example, in
            segmentation problems featuring a "void" class (commonly -1
            or 255) in segmentation maps.
            By default (`ignore_class=None`), all classes are considered.

    Returns:
        Output tensor.

    Raises:
        ValueError: if `axis` is neither -1 nor one of the axes of `output`.
    """
    ...

@keras_export("keras.backend.binary_crossentropy")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def binary_crossentropy(target, output, from_logits=...):
    """Binary crossentropy between an output tensor and a target tensor.

    Args:
        target: A tensor with the same shape as `output`.
        output: A tensor.
        from_logits: Whether `output` is expected to be a logits tensor.
            By default, we consider that `output`
            encodes a probability distribution.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.binary_focal_crossentropy")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def binary_focal_crossentropy(target, output, apply_class_balancing=..., alpha=..., gamma=..., from_logits=...):
    """Binary focal crossentropy between an output tensor and a target tensor.

    According to [Lin et al., 2018](https://arxiv.org/pdf/1708.02002.pdf), it
    helps to apply a focal factor to down-weight easy examples and focus more on
    hard examples. By default, the focal tensor is computed as follows:

    `focal_factor = (1 - output) ** gamma` for class 1
    `focal_factor = output ** gamma` for class 0
    where `gamma` is a focusing parameter. When `gamma` = 0, there is no focal
    effect on the binary crossentropy.

    If `apply_class_balancing == True`, this function also takes into account a
    weight balancing factor for the binary classes 0 and 1 as follows:

    `weight = alpha` for class 1 (`target == 1`)
    `weight = 1 - alpha` for class 0
    where `alpha` is a float in the range of `[0, 1]`.

    Args:
      target: A tensor with the same shape as `output`.
      output: A tensor.
      apply_class_balancing: A bool, whether to apply weight balancing on the
        binary classes 0 and 1.
      alpha: A weight balancing factor for class 1, default is `0.25` as
        mentioned in the reference. The weight for class 0 is `1.0 - alpha`.
      gamma: A focusing parameter, default is `2.0` as mentioned in the
        reference.
      from_logits: Whether `output` is expected to be a logits tensor. By
        default, we consider that `output` encodes a probability distribution.

    Returns:
      A tensor.
    """
    ...

@keras_export("keras.backend.sigmoid")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def sigmoid(x):
    """Element-wise sigmoid.

    Args:
        x: A tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.hard_sigmoid")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def hard_sigmoid(x):
    """Segment-wise linear approximation of sigmoid.

    Faster than sigmoid.
    Returns `0.` if `x < -2.5`, `1.` if `x > 2.5`.
    In `-2.5 <= x <= 2.5`, returns `0.2 * x + 0.5`.

    Args:
        x: A tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.tanh")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def tanh(x):
    """Element-wise tanh.

    Args:
        x: A tensor or variable.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.dropout")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def dropout(x, level, noise_shape=..., seed=...):
    """Sets entries in `x` to zero at random, while scaling the entire tensor.

    Args:
        x: tensor
        level: fraction of the entries in the tensor
            that will be set to 0.
        noise_shape: shape for randomly generated keep/drop flags,
            must be broadcastable to the shape of `x`
        seed: random seed to ensure determinism.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.l2_normalize")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def l2_normalize(x, axis=...):
    """Normalizes a tensor wrt the L2 norm alongside the specified axis.

    Args:
        x: Tensor or variable.
        axis: axis along which to perform normalization.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.in_top_k")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def in_top_k(predictions, targets, k):
    """Returns whether the `targets` are in the top `k` `predictions`.

    Args:
        predictions: A tensor of shape `(batch_size, classes)` and type
          `float32`.
        targets: A 1D tensor of length `batch_size` and type `int32` or `int64`.
        k: An `int`, number of top elements to consider.

    Returns:
        A 1D tensor of length `batch_size` and type `bool`.
        `output[i]` is `True` if `predictions[i, targets[i]]` is within top-`k`
        values of `predictions[i]`.
    """
    ...

@keras_export("keras.backend.conv1d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def conv1d(x, kernel, strides=..., padding=..., data_format=..., dilation_rate=...):
    """1D convolution.

    Args:
        x: Tensor or variable.
        kernel: kernel tensor.
        strides: stride integer.
        padding: string, `"same"`, `"causal"` or `"valid"`.
        data_format: string, one of "channels_last", "channels_first".
        dilation_rate: integer dilate rate.

    Returns:
        A tensor, result of 1D convolution.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
    """
    ...

@keras_export("keras.backend.conv2d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def conv2d(x, kernel, strides=..., padding=..., data_format=..., dilation_rate=...):
    """2D convolution.

    Args:
        x: Tensor or variable.
        kernel: kernel tensor.
        strides: strides tuple.
        padding: string, `"same"` or `"valid"`.
        data_format: `"channels_last"` or `"channels_first"`.
        dilation_rate: tuple of 2 integers.

    Returns:
        A tensor, result of 2D convolution.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
    """
    ...

@keras_export("keras.backend.conv2d_transpose")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def conv2d_transpose(x, kernel, output_shape, strides=..., padding=..., data_format=..., dilation_rate=...):
    """2D deconvolution (i.e.

    transposed convolution).

    Args:
        x: Tensor or variable.
        kernel: kernel tensor.
        output_shape: 1D int tensor for the output shape.
        strides: strides tuple.
        padding: string, `"same"` or `"valid"`.
        data_format: string, `"channels_last"` or `"channels_first"`.
        dilation_rate: Tuple of 2 integers.

    Returns:
        A tensor, result of transposed 2D convolution.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
    """
    ...

def separable_conv1d(x, depthwise_kernel, pointwise_kernel, strides=..., padding=..., data_format=..., dilation_rate=...):
    """1D convolution with separable filters.

    Args:
        x: input tensor
        depthwise_kernel: convolution kernel for the depthwise convolution.
        pointwise_kernel: kernel for the 1x1 convolution.
        strides: stride integer.
        padding: string, `"same"` or `"valid"`.
        data_format: string, `"channels_last"` or `"channels_first"`.
        dilation_rate: integer dilation rate.

    Returns:
        Output tensor.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
    """
    ...

@keras_export("keras.backend.separable_conv2d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def separable_conv2d(x, depthwise_kernel, pointwise_kernel, strides=..., padding=..., data_format=..., dilation_rate=...):
    """2D convolution with separable filters.

    Args:
        x: input tensor
        depthwise_kernel: convolution kernel for the depthwise convolution.
        pointwise_kernel: kernel for the 1x1 convolution.
        strides: strides tuple (length 2).
        padding: string, `"same"` or `"valid"`.
        data_format: string, `"channels_last"` or `"channels_first"`.
        dilation_rate: tuple of integers,
            dilation rates for the separable convolution.

    Returns:
        Output tensor.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
        ValueError: if `strides` is not a tuple of 2 integers.
    """
    ...

@keras_export("keras.backend.depthwise_conv2d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def depthwise_conv2d(x, depthwise_kernel, strides=..., padding=..., data_format=..., dilation_rate=...):
    """2D convolution with separable filters.

    Args:
        x: input tensor
        depthwise_kernel: convolution kernel for the depthwise convolution.
        strides: strides tuple (length 2).
        padding: string, `"same"` or `"valid"`.
        data_format: string, `"channels_last"` or `"channels_first"`.
        dilation_rate: tuple of integers,
            dilation rates for the separable convolution.

    Returns:
        Output tensor.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
    """
    ...

@keras_export("keras.backend.conv3d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def conv3d(x, kernel, strides=..., padding=..., data_format=..., dilation_rate=...):
    """3D convolution.

    Args:
        x: Tensor or variable.
        kernel: kernel tensor.
        strides: strides tuple.
        padding: string, `"same"` or `"valid"`.
        data_format: string, `"channels_last"` or `"channels_first"`.
        dilation_rate: tuple of 3 integers.

    Returns:
        A tensor, result of 3D convolution.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
    """
    ...

def conv3d_transpose(x, kernel, output_shape, strides=..., padding=..., data_format=...):
    """3D deconvolution (i.e.

    transposed convolution).

    Args:
        x: input tensor.
        kernel: kernel tensor.
        output_shape: 1D int tensor for the output shape.
        strides: strides tuple.
        padding: string, "same" or "valid".
        data_format: string, `"channels_last"` or `"channels_first"`.

    Returns:
        A tensor, result of transposed 3D convolution.

    Raises:
        ValueError: if `data_format` is neither `channels_last` or
        `channels_first`.
    """
    ...

@keras_export("keras.backend.pool2d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def pool2d(x, pool_size, strides=..., padding=..., data_format=..., pool_mode=...):
    """2D Pooling.

    Args:
        x: Tensor or variable.
        pool_size: tuple of 2 integers.
        strides: tuple of 2 integers.
        padding: string, `"same"` or `"valid"`.
        data_format: string, `"channels_last"` or `"channels_first"`.
        pool_mode: string, `"max"` or `"avg"`.

    Returns:
        A tensor, result of 2D pooling.

    Raises:
        ValueError: if `data_format` is neither `"channels_last"` or
        `"channels_first"`.
        ValueError: if `pool_size` is not a tuple of 2 integers.
        ValueError: if `strides` is not a tuple of 2 integers.
        ValueError: if `pool_mode` is neither `"max"` or `"avg"`.
    """
    ...

@keras_export("keras.backend.pool3d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def pool3d(x, pool_size, strides=..., padding=..., data_format=..., pool_mode=...):
    """3D Pooling.

    Args:
        x: Tensor or variable.
        pool_size: tuple of 3 integers.
        strides: tuple of 3 integers.
        padding: string, `"same"` or `"valid"`.
        data_format: string, `"channels_last"` or `"channels_first"`.
        pool_mode: string, `"max"` or `"avg"`.

    Returns:
        A tensor, result of 3D pooling.

    Raises:
        ValueError: if `data_format` is neither `"channels_last"` or
        `"channels_first"`.
        ValueError: if `pool_mode` is neither `"max"` or `"avg"`.
    """
    ...

def local_conv(inputs, kernel, kernel_size, strides, output_shape, data_format=...):
    """Apply N-D convolution with un-shared weights.

    Args:
        inputs: (N+2)-D tensor with shape
            (batch_size, channels_in, d_in1, ..., d_inN)
            if data_format='channels_first', or
            (batch_size, d_in1, ..., d_inN, channels_in)
            if data_format='channels_last'.
        kernel: the unshared weight for N-D convolution,
            with shape (output_items, feature_dim, channels_out), where
            feature_dim = np.prod(kernel_size) * channels_in,
            output_items = np.prod(output_shape).
        kernel_size: a tuple of N integers, specifying the
            spatial dimensions of the N-D convolution window.
        strides: a tuple of N integers, specifying the strides
            of the convolution along the spatial dimensions.
        output_shape: a tuple of (d_out1, ..., d_outN) specifying the spatial
            dimensionality of the output.
        data_format: string, "channels_first" or "channels_last".

    Returns:
        An (N+2)-D tensor with shape:
        (batch_size, channels_out) + output_shape
        if data_format='channels_first', or:
        (batch_size,) + output_shape + (channels_out,)
        if data_format='channels_last'.

    Raises:
        ValueError: if `data_format` is neither
        `channels_last` nor `channels_first`.
    """
    ...

@keras_export("keras.backend.local_conv1d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def local_conv1d(inputs, kernel, kernel_size, strides, data_format=...):
    """Apply 1D conv with un-shared weights.

    Args:
        inputs: 3D tensor with shape:
            (batch_size, steps, input_dim)
            if data_format is "channels_last" or
            (batch_size, input_dim, steps)
            if data_format is "channels_first".
        kernel: the unshared weight for convolution,
            with shape (output_length, feature_dim, filters).
        kernel_size: a tuple of a single integer,
            specifying the length of the 1D convolution window.
        strides: a tuple of a single integer,
            specifying the stride length of the convolution.
        data_format: the data format, channels_first or channels_last.

    Returns:
        A 3d tensor with shape:
        (batch_size, output_length, filters)
        if data_format='channels_first'
        or 3D tensor with shape:
        (batch_size, filters, output_length)
        if data_format='channels_last'.
    """
    ...

@keras_export("keras.backend.local_conv2d")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def local_conv2d(inputs, kernel, kernel_size, strides, output_shape, data_format=...):
    """Apply 2D conv with un-shared weights.

    Args:
        inputs: 4D tensor with shape:
            (batch_size, filters, new_rows, new_cols)
            if data_format='channels_first'
            or 4D tensor with shape:
            (batch_size, new_rows, new_cols, filters)
            if data_format='channels_last'.
        kernel: the unshared weight for convolution,
            with shape (output_items, feature_dim, filters).
        kernel_size: a tuple of 2 integers, specifying the
            width and height of the 2D convolution window.
        strides: a tuple of 2 integers, specifying the strides
            of the convolution along the width and height.
        output_shape: a tuple with (output_row, output_col).
        data_format: the data format, channels_first or channels_last.

    Returns:
        A 4D tensor with shape:
        (batch_size, filters, new_rows, new_cols)
        if data_format='channels_first'
        or 4D tensor with shape:
        (batch_size, new_rows, new_cols, filters)
        if data_format='channels_last'.
    """
    ...

@keras_export("keras.backend.bias_add")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def bias_add(x, bias, data_format=...):
    """Adds a bias vector to a tensor.

    Args:
        x: Tensor or variable.
        bias: Bias tensor to add.
        data_format: string, `"channels_last"` or `"channels_first"`.

    Returns:
        Output tensor.

    Raises:
        ValueError: In one of the two cases below:
                    1. invalid `data_format` argument.
                    2. invalid bias shape.
                       the bias should be either a vector or
                       a tensor with ndim(x) - 1 dimension
    """
    ...

@keras_export("keras.backend.random_normal")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def random_normal(shape, mean=..., stddev=..., dtype=..., seed=...):
    """Returns a tensor with normal distribution of values.

    It is an alias to `tf.random.normal`.

    Args:
        shape: A tuple of integers, the shape of tensor to create.
        mean: A float, the mean value of the normal distribution to draw
          samples. Default to 0.0.
        stddev: A float, the standard deviation of the normal distribution
          to draw samples. Default to 1.0.
        dtype: `tf.dtypes.DType`, dtype of returned tensor. Default to use Keras
          backend dtype which is float32.
        seed: Integer, random seed. Will use a random numpy integer when not
          specified.

    Returns:
        A tensor with normal distribution of values.

    Example:

    >>> random_normal_tensor = tf.keras.backend.random_normal(shape=(2,3),
    ... mean=0.0, stddev=1.0)
    >>> random_normal_tensor
    <tf.Tensor: shape=(2, 3), dtype=float32, numpy=...,
    dtype=float32)>
    """
    ...

@keras_export("keras.backend.random_uniform")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def random_uniform(shape, minval=..., maxval=..., dtype=..., seed=...):
    """Returns a tensor with uniform distribution of values.

    Args:
        shape: A tuple of integers, the shape of tensor to create.
        minval: A float, lower boundary of the uniform distribution
            to draw samples.
        maxval: A float, upper boundary of the uniform distribution
            to draw samples.
        dtype: String, dtype of returned tensor.
        seed: Integer, random seed.

    Returns:
        A tensor.

    Example:

    >>> random_uniform_tensor = tf.keras.backend.random_uniform(shape=(2,3),
    ... minval=0.0, maxval=1.0)
    >>> random_uniform_tensor
    <tf.Tensor: shape=(2, 3), dtype=float32, numpy=...,
    dtype=float32)>
    """
    ...

@keras_export("keras.backend.random_binomial")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def random_binomial(shape, p=..., dtype=..., seed=...):
    """Returns a tensor with random binomial distribution of values.

    DEPRECATED, use `tf.keras.backend.random_bernoulli` instead.

    The binomial distribution with parameters `n` and `p` is the probability
    distribution of the number of successful Bernoulli process. Only supports
    `n` = 1 for now.

    Args:
        shape: A tuple of integers, the shape of tensor to create.
        p: A float, `0. <= p <= 1`, probability of binomial distribution.
        dtype: String, dtype of returned tensor.
        seed: Integer, random seed.

    Returns:
        A tensor.

    Example:

    >>> random_binomial_tensor = tf.keras.backend.random_binomial(shape=(2,3),
    ... p=0.5)
    >>> random_binomial_tensor
    <tf.Tensor: shape=(2, 3), dtype=float32, numpy=...,
    dtype=float32)>
    """
    ...

@keras_export("keras.backend.random_bernoulli")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def random_bernoulli(shape, p=..., dtype=..., seed=...):
    """Returns a tensor with random bernoulli distribution of values.

    Args:
        shape: A tuple of integers, the shape of tensor to create.
        p: A float, `0. <= p <= 1`, probability of bernoulli distribution.
        dtype: String, dtype of returned tensor.
        seed: Integer, random seed.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.truncated_normal")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def truncated_normal(shape, mean=..., stddev=..., dtype=..., seed=...):
    """Returns a tensor with truncated random normal distribution of values.

    The generated values follow a normal distribution
    with specified mean and standard deviation,
    except that values whose magnitude is more than
    two standard deviations from the mean are dropped and re-picked.

    Args:
        shape: A tuple of integers, the shape of tensor to create.
        mean: Mean of the values.
        stddev: Standard deviation of the values.
        dtype: String, dtype of returned tensor.
        seed: Integer, random seed.

    Returns:
        A tensor.
    """
    ...

@keras_export("keras.backend.ctc_label_dense_to_sparse")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def ctc_label_dense_to_sparse(labels, label_lengths):
    """Converts CTC labels from dense to sparse.

    Args:
        labels: dense CTC labels.
        label_lengths: length of the labels.

    Returns:
        A sparse tensor representation of the labels.
    """
    ...

@keras_export("keras.backend.ctc_batch_cost")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def ctc_batch_cost(y_true, y_pred, input_length, label_length):
    """Runs CTC loss algorithm on each batch element.

    Args:
        y_true: tensor `(samples, max_string_length)`
            containing the truth labels.
        y_pred: tensor `(samples, time_steps, num_categories)`
            containing the prediction, or output of the softmax.
        input_length: tensor `(samples, 1)` containing the sequence length for
            each batch item in `y_pred`.
        label_length: tensor `(samples, 1)` containing the sequence length for
            each batch item in `y_true`.

    Returns:
        Tensor with shape (samples,1) containing the
            CTC loss of each element.
    """
    ...

@keras_export("keras.backend.ctc_decode")
@tf.__internal__.dispatch.add_dispatch_support
@doc_controls.do_not_generate_docs
def ctc_decode(y_pred, input_length, greedy=..., beam_width=..., top_paths=...): # -> tuple[list[Unknown], Unknown]:
    """Decodes the output of a softmax.

    Can use either greedy search (also known as best path)
    or a constrained dictionary search.

    Args:
        y_pred: tensor `(samples, time_steps, num_categories)`
            containing the prediction, or output of the softmax.
        input_length: tensor `(samples, )` containing the sequence length for
            each batch item in `y_pred`.
        greedy: perform much faster best-path search if `true`.
            This does not use a dictionary.
        beam_width: if `greedy` is `false`: a beam search decoder will be used
            with a beam of this width.
        top_paths: if `greedy` is `false`,
            how many of the most probable paths will be returned.

    Returns:
        Tuple:
            List: if `greedy` is `true`, returns a list of one element that
                contains the decoded sequence.
                If `false`, returns the `top_paths` most probable
                decoded sequences.
                Each decoded sequence has shape (samples, time_steps).
                Important: blank labels are returned as `-1`.
            Tensor `(top_paths, )` that contains
                the log probability of each decoded sequence.
    """
    ...

@keras_export("keras.backend.map_fn")
@doc_controls.do_not_generate_docs
def map_fn(fn, elems, name=..., dtype=...):
    """Map the function fn over the elements elems and return the outputs.

    Args:
        fn: Callable that will be called upon each element in elems
        elems: tensor
        name: A string name for the map node in the graph
        dtype: Output data type.

    Returns:
        Tensor with dtype `dtype`.
    """
    ...

@keras_export("keras.backend.foldl")
@doc_controls.do_not_generate_docs
def foldl(fn, elems, initializer=..., name=...):
    """Reduce elems using fn to combine them from left to right.

    Args:
        fn: Callable that will be called upon each element in elems and an
            accumulator, for instance `lambda acc, x: acc + x`
        elems: tensor
        initializer: The first value used (`elems[0]` in case of None)
        name: A string name for the foldl node in the graph

    Returns:
        Tensor with same type and shape as `initializer`.
    """
    ...

@keras_export("keras.backend.foldr")
@doc_controls.do_not_generate_docs
def foldr(fn, elems, initializer=..., name=...):
    """Reduce elems using fn to combine them from right to left.

    Args:
        fn: Callable that will be called upon each element in elems and an
            accumulator, for instance `lambda acc, x: acc + x`
        elems: tensor
        initializer: The first value used (`elems[-1]` in case of None)
        name: A string name for the foldr node in the graph

    Returns:
        Same type and shape as initializer
    """
    ...

if "KERAS_HOME" in os.environ:
    _keras_dir = ...
else:
    _keras_base_dir = ...
    _keras_dir = ...
_config_path = ...
if os.path.exists(_config_path):
    _floatx = ...
    _epsilon = ...
    _image_data_format = ...
if notos.path.exists(_keras_dir):
    ...
if notos.path.exists(_config_path):
    _config = ...
def configure_and_create_distributed_session(distribution_strategy): # -> None:
    """Configure session config and create a session with it."""
    ...

def is_tpu_strategy(strategy): # -> bool:
    """Returns whether input is a TPUStrategy instance or subclass instance."""
    ...

def cast_variables_to_tensor(tensors):
    ...

def convert_inputs_if_ragged(inputs): # -> tuple[Unknown, None] | tuple[Unknown, Unknown]:
    """Converts any ragged tensors to dense."""
    ...

def maybe_convert_to_ragged(is_ragged_input, output, nested_row_lengths, go_backwards=...):
    """Converts any ragged input back to its initial structure."""
    ...

class ContextValueCache(weakref.WeakKeyDictionary):
    """Container that caches (possibly tensor) values based on the context.

    This class is similar to defaultdict, where values may be produced by the
    default factory specified during initialization. This class also has a
    default value for the key (when key is `None`) -- the key is set to the
    current graph or eager context. The default factories for key and value are
    only used in `__getitem__` and `setdefault`. The `.get()` behavior remains
    the same.

    This object will return the value of the current graph or closest parent
    graph if the current graph is a function. This is to reflect the fact that
    if a tensor is created in eager/graph, child functions may capture that
    tensor.

    The default factory method may accept keyword arguments (unlike defaultdict,
    which only accepts callables with 0 arguments). To pass keyword arguments to
    `default_factory`, use the `setdefault` method instead of `__getitem__`.

    An example of how this class can be used in different contexts:

    ```
    cache = ContextValueCache(int)

    # Eager mode
    cache[None] += 2
    cache[None] += 4
    assert cache[None] == 6

    # Graph mode
    with tf.Graph().as_default() as g:
      cache[None] += 5
      cache[g] += 3
    assert cache[g] == 8
    ```

    Example of a default factory with arguments:

    ```
    cache = ContextValueCache(lambda x: x + 1)
    g = tf.get_default_graph()

    # Example with keyword argument.
    value = cache.setdefault(key=g, kwargs={'x': 3})
    assert cache[g] == 4
    ```
    """
    def __init__(self, default_factory) -> None:
        ...
    
    def __getitem__(self, key):
        """Gets the value at key (or current context), or sets default value.

        Args:
          key: May be `None` or `Graph`object. When `None`, the key is set to
            the current context.

        Returns:
          Either the cached or default value.
        """
        ...
    
    def setdefault(self, key=..., default=..., kwargs=...):
        """Sets the default value if key is not in dict, and returns the
        value."""
        ...
    


_GRAPH_LEARNING_PHASES = ...
_GRAPH_VARIABLES = ...
_GRAPH_TF_OPTIMIZERS = ...
