"""
This type stub file was generated by pyright.
"""

from typing import Iterator, List, Optional, TYPE_CHECKING, Tuple, Union
from typing_extensions import TypedDict

'''
The liac-arff module implements functions to read and write ARFF files in
Python. It was created in the Connectionist Artificial Intelligence Laboratory
(LIAC), which takes place at the Federal University of Rio Grande do Sul
(UFRGS), in Brazil.

ARFF (Attribute-Relation File Format) is an file format specially created for
describe datasets which are commonly used for machine learning experiments and
software. This file format was created to be used in Weka, the best
representative software for machine learning automated experiments.

An ARFF file can be divided into two sections: header and data. The Header
describes the metadata of the dataset, including a general description of the
dataset, its name and its attributes. The source below is an example of a
header section in a XOR dataset::

    %
    % XOR Dataset
    %
    % Created by Renato Pereira
    %            rppereira@inf.ufrgs.br
    %            http://inf.ufrgs.br/~rppereira
    %
    %
    @RELATION XOR

    @ATTRIBUTE input1 REAL
    @ATTRIBUTE input2 REAL
    @ATTRIBUTE y REAL

The Data section of an ARFF file describes the observations of the dataset, in
the case of XOR dataset::

    @DATA
    0.0,0.0,0.0
    0.0,1.0,1.0
    1.0,0.0,1.0
    1.0,1.0,0.0
    %
    %
    %

Notice that several lines are starting with an ``%`` symbol, denoting a
comment, thus, lines with ``%`` at the beginning will be ignored, except by the
description part at the beginning of the file. The declarations ``@RELATION``,
``@ATTRIBUTE``, and ``@DATA`` are all case insensitive and obligatory.

For more information and details about the ARFF file description, consult
http://www.cs.waikato.ac.nz/~ml/weka/arff.html


ARFF Files in Python
~~~~~~~~~~~~~~~~~~~~

This module uses built-ins python objects to represent a deserialized ARFF
file. A dictionary is used as the container of the data and metadata of ARFF,
and have the following keys:

- **description**: (OPTIONAL) a string with the description of the dataset.
- **relation**: (OBLIGATORY) a string with the name of the dataset.
- **attributes**: (OBLIGATORY) a list of attributes with the following
  template::

    (attribute_name, attribute_type)

  the attribute_name is a string, and attribute_type must be an string
  or a list of strings.
- **data**: (OBLIGATORY) a list of data instances. Each data instance must be
  a list with values, depending on the attributes.

The above keys must follow the case which were described, i.e., the keys are
case sensitive. The attribute type ``attribute_type`` must be one of these
strings (they are not case sensitive): ``NUMERIC``, ``INTEGER``, ``REAL`` or
``STRING``. For nominal attributes, the ``atribute_type`` must be a list of
strings.

In this format, the XOR dataset presented above can be represented as a python
object as::

    xor_dataset = {
        'description': 'XOR Dataset',
        'relation': 'XOR',
        'attributes': [
            ('input1', 'REAL'),
            ('input2', 'REAL'),
            ('y', 'REAL'),
        ],
        'data': [
            [0.0, 0.0, 0.0],
            [0.0, 1.0, 1.0],
            [1.0, 0.0, 1.0],
            [1.0, 1.0, 0.0]
        ]
    }


Features
~~~~~~~~

This module provides several features, including:

- Read and write ARFF files using python built-in structures, such dictionaries
  and lists;
- Supports `scipy.sparse.coo <http://docs.scipy
  .org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html#scipy.sparse.coo_matrix>`_
  and lists of dictionaries as used by SVMLight
- Supports the following attribute types: NUMERIC, REAL, INTEGER, STRING, and
  NOMINAL;
- Has an interface similar to other built-in modules such as ``json``, or
  ``zipfile``;
- Supports read and write the descriptions of files;
- Supports missing values and names with spaces;
- Supports unicode values and names;
- Fully compatible with Python 2.7+, Python 3.5+, pypy and pypy3;
- Under `MIT License <http://opensource.org/licenses/MIT>`_

'''
__author__ = ...
__author_email__ = ...
__version__ = ...
_SIMPLE_TYPES = ...
_TK_DESCRIPTION = ...
_TK_COMMENT = ...
_TK_RELATION = ...
_TK_ATTRIBUTE = ...
_TK_DATA = ...
_RE_RELATION = ...
_RE_ATTRIBUTE = ...
_RE_QUOTE_CHARS = ...
_RE_ESCAPE_CHARS = ...
_RE_SPARSE_LINE = ...
_RE_NONTRIVIAL_DATA = ...
ArffDenseDataType = Iterator[List]
ArffSparseDataType = Tuple[List, ...]
if TYPE_CHECKING:
    class ArffContainerType(TypedDict):
        description: str
        relation: str
        attributes: List
        data: Union[ArffDenseDataType, ArffSparseDataType]
        ...
    
    
else:
    ...
_ESCAPE_SUB_MAP = ...
_UNESCAPE_SUB_MAP = ...
DENSE = ...
COO = ...
LOD = ...
DENSE_GEN = ...
LOD_GEN = ...
_SUPPORTED_DATA_STRUCTURES = ...
class ArffException(Exception):
    message: Optional[str] = ...
    def __init__(self) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class BadRelationFormat(ArffException):
    '''Error raised when the relation declaration is in an invalid format.'''
    message = ...


class BadAttributeFormat(ArffException):
    '''Error raised when some attribute declaration is in an invalid format.'''
    message = ...


class BadDataFormat(ArffException):
    '''Error raised when some data instance is in an invalid format.'''
    def __init__(self, value) -> None:
        ...
    


class BadAttributeType(ArffException):
    '''Error raised when some invalid type is provided into the attribute
    declaration.'''
    message = ...


class BadAttributeName(ArffException):
    '''Error raised when an attribute name is provided twice the attribute
    declaration.'''
    def __init__(self, value, value2) -> None:
        ...
    


class BadNominalValue(ArffException):
    '''Error raised when a value in used in some data instance but is not
    declared into it respective attribute declaration.'''
    def __init__(self, value) -> None:
        ...
    


class BadNominalFormatting(ArffException):
    '''Error raised when a nominal value with space is not properly quoted.'''
    def __init__(self, value) -> None:
        ...
    


class BadNumericalValue(ArffException):
    '''Error raised when and invalid numerical value is used in some data
    instance.'''
    message = ...


class BadStringValue(ArffException):
    '''Error raise when a string contains space but is not quoted.'''
    message = ...


class BadLayout(ArffException):
    '''Error raised when the layout of the ARFF file has something wrong.'''
    message = ...
    def __init__(self, msg=...) -> None:
        ...
    


class BadObject(ArffException):
    '''Error raised when the object representing the ARFF file has something
    wrong.'''
    def __init__(self, msg=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


def encode_string(s): # -> str:
    ...

class EncodedNominalConversor:
    def __init__(self, values) -> None:
        ...
    
    def __call__(self, value): # -> int:
        ...
    


class NominalConversor:
    def __init__(self, values) -> None:
        ...
    
    def __call__(self, value): # -> str:
        ...
    


class DenseGeneratorData:
    '''Internal helper class to allow for different matrix types without
    making the code a huge collection of if statements.'''
    def decode_rows(self, stream, conversors): # -> Generator[list[Unknown | None] | list[str | Any | int | None] | list[str | None] | list[str | Any | None], None, None]:
        ...
    
    def encode_data(self, data, attributes): # -> Generator[LiteralString, None, None]:
        '''(INTERNAL) Encodes a line of data.

        Data instances follow the csv format, i.e, attribute values are
        delimited by commas. After converted from csv.

        :param data: a list of values.
        :param attributes: a list of attributes. Used to check if data is valid.
        :return: a string with the encoded data line.
        '''
        ...
    


class _DataListMixin:
    """Mixin to return a list from decode_rows instead of a generator"""
    def decode_rows(self, stream, conversors): # -> list[Unknown]:
        ...
    


class Data(_DataListMixin, DenseGeneratorData):
    ...


class COOData:
    def decode_rows(self, stream, conversors): # -> tuple[list[Unknown], list[Unknown], list[Unknown]]:
        ...
    
    def encode_data(self, data, attributes): # -> Generator[LiteralString, None, None]:
        ...
    


class LODGeneratorData:
    def decode_rows(self, stream, conversors): # -> Generator[dict[int, Unknown | None], None, None]:
        ...
    
    def encode_data(self, data, attributes): # -> Generator[LiteralString, None, None]:
        ...
    


class LODData(_DataListMixin, LODGeneratorData):
    ...


class ArffDecoder:
    '''An ARFF decoder.'''
    def __init__(self) -> None:
        '''Constructor.'''
        ...
    
    def decode(self, s, encode_nominal=..., return_type=...): # -> ArffContainerType:
        '''Returns the Python representation of a given ARFF file.

        When a file object is passed as an argument, this method reads lines
        iteratively, avoiding to load unnecessary information to the memory.

        :param s: a string or file object with the ARFF file.
        :param encode_nominal: boolean, if True perform a label encoding
            while reading the .arff file.
        :param return_type: determines the data structure used to store the
            dataset. Can be one of `arff.DENSE`, `arff.COO`, `arff.LOD`,
            `arff.DENSE_GEN` or `arff.LOD_GEN`.
            Consult the sections on `working with sparse data`_ and `loading
            progressively`_.
        '''
        ...
    


class ArffEncoder:
    '''An ARFF encoder.'''
    def encode(self, obj): # -> str:
        '''Encodes a given object to an ARFF file.

        :param obj: the object containing the ARFF information.
        :return: the ARFF file as an string.
        '''
        ...
    
    def iter_encode(self, obj): # -> Generator[str | LiteralString, None, None]:
        '''The iterative version of `arff.ArffEncoder.encode`.

        This encodes iteratively a given object and return, one-by-one, the
        lines of the ARFF file.

        :param obj: the object containing the ARFF information.
        :return: (yields) the ARFF file as strings.
        '''
        ...
    


def load(fp, encode_nominal=..., return_type=...): # -> ArffContainerType:
    '''Load a file-like object containing the ARFF document and convert it into
    a Python object.

    :param fp: a file-like object.
    :param encode_nominal: boolean, if True perform a label encoding
        while reading the .arff file.
    :param return_type: determines the data structure used to store the
        dataset. Can be one of `arff.DENSE`, `arff.COO`, `arff.LOD`,
        `arff.DENSE_GEN` or `arff.LOD_GEN`.
        Consult the sections on `working with sparse data`_ and `loading
        progressively`_.
    :return: a dictionary.
     '''
    ...

def loads(s, encode_nominal=..., return_type=...): # -> ArffContainerType:
    '''Convert a string instance containing the ARFF document into a Python
    object.

    :param s: a string object.
    :param encode_nominal: boolean, if True perform a label encoding
        while reading the .arff file.
    :param return_type: determines the data structure used to store the
        dataset. Can be one of `arff.DENSE`, `arff.COO`, `arff.LOD`,
        `arff.DENSE_GEN` or `arff.LOD_GEN`.
        Consult the sections on `working with sparse data`_ and `loading
        progressively`_.
    :return: a dictionary.
    '''
    ...

def dump(obj, fp):
    '''Serialize an object representing the ARFF document to a given file-like
    object.

    :param obj: a dictionary.
    :param fp: a file-like object.
    '''
    ...

def dumps(obj): # -> str:
    '''Serialize an object representing the ARFF document, returning a string.

    :param obj: a dictionary.
    :return: a string with the ARFF document.
    '''
    ...

